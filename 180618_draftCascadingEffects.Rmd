---
title: "Cascading regime shifts within and across scales"
author: |
    | Juan C. Rocha^1,2^, Garry Peterson^1^, Örjan Bodin^1^, Simon A. Levin^3^
    | \small ^1^Stockholm Resilience Centre, Stockholm University, Kräftriket 2B, 10691 Stockholm
    | \small ^2^Beijer Institute, Swedish Royal Academy of Sciences, Lilla Frescativägen 4A, 104 05 Stockholm
    | \small ^3^Department of Ecology & Evolutionary Biology, Princeton University, 106A Guyot Hall, Princeton, NJ 08544-1003
# author:
#   - name: Juan C. Rocha^a^
#     email: juan.rocha@su.se
#   - name: Garry D. Peterson^b^
#   - name: Örjan Bodin^a^
#   - name: Simon A. Levin^c^
# address:
#   - code: 1
#     address: Stockholm Resilience Centre, Stockholm University, Kräftriket 2B, 10691 Stockholm
#   - code: 2
#     address: Beijer Institute, Swedish Royal Academy of Sciences, Lilla Frescativägen 4A, 104 05 Stockholm
#   - code: 3
#     address: Princeton University, Department of Ecology & Evolutionary Biology, 106A Guyot Hall, Princeton, NJ 08544-1003
# date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  word_document:
    toc: no
  pdf_document:
    dev: pdf
    keep_tex: yes
    latex_engine: pdflatex
    toc: no
  html_document:
    df_print: paged
    toc: no
citecolor: blue
csl: science.csl
documentclass: article
fontsize: 9pt
header-includes:
- \usepackage{dcolumn}
- \usepackage[T1]{fontenc}
- \usepackage{inputenc}
keywords: regime shifts, cascading effects, tele-connections, coupled critical transitions,
  networks
lineno: no
linkcolor: blue
bibliography: cascading.bib
abstract: |
  Regime shifts are large, abrupt and persistent critical transitions in the function and structure of systems [@Scheffer:2003p339; @Scheffer:2001uu]. Yet it is largely unknown how these transitions will interact, whether the occurrence of one will increase the likelihood of another, or simply correlate at distant places. Here we explore two types of cascading effects: domino effects create one-way dependencies, while hidden feedbacks produce two-way interactions; and compare them with the control case of driver sharing which can induce correlations. Using 30 regime shifts described as networks, we show that 45% of the pair-wise combinations of regime shifts present at least one plausible structural interdependence. Driver sharing is more common in aquatic systems, while hidden feedbacks are more commonly found in terrestrial and Earth systems tipping points. The likelihood of cascading effects depends on cross-scale interactions, but differs for each cascading effect type. Regime shifts should not be studied in isolation: instead, methods and data collection should account for potential teleconnections.
urlcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dev = "pdf", dpi = 300)
options(knitr.table.format = "latex")
options(tinytex.verbose = TRUE)

## This draft version contains the latest additions by Garry.

rm(list = ls())
set.seed(12345)
library(knitr)
library (dplyr)
library (tidyr)
library(forcats)
library (network)
library (sna)
library(RColorBrewer)
library(ggplot2)
library(GGally)
library(viridis)
library(ggrepel)

# for plotting
library(ggmap)
library(maptools)
library(maps)
library(mapproj)

library(gridBase)
library(grid)
library(gridExtra)
library(png)


## for cleaning models
library(car)
library(broom)
library(sandwich); library(lmtest)

### ERGMS for Regime Shifts
library(ergm.count)

## for tables
library(kableExtra)

# setwd('~/Documents/Projects/Cascading Effects/Domino')
# Sys.setenv(RSTUDIO_PANDOC="/Applications/RStudio.app/Contents/MacOS/pandoc")
# rmarkdown::render('170125_draft.Rmd', output_format = 'pdf_document')

  # html_document:
  #   code_folding: hide
  #   dev: pdf
  #   self_contained: yes
  #   toc: yes
  #   toc_float:
  #     collapsed: no
  #     smooth_scroll: no
  # word_document: null

# - \usepackage{lineno}
# - \linenumbers


```


```{r data_ergm, include=FALSE}
# this loads the data, it was cleaned and prepared with script 170329_read_data.R
# and load the ergm models fitted with script 170329_ergms.R

load('~/Documents/Projects/Cascading Effects/170525_ergm_data.RData')


## updated functions ##
## this can be deleted in the future

## Updated ploting function
plotnet <- function(net, ...){
	plot.network(net, #mode='circle',
			vertex.col = alpha(net %v% 'col', 0.7),
			# label = network.vertex.names(net),
			# label.cex= 1,
			main = net %n% 'name', col.main = "gray44", cex.main = 1.2,
			vertex.border = 0,
			usecurve=T,
			vertex.cex= 2, #2 + scale(net %v% 'fb'),
			label.pos= 5,
			edge.col= alpha(net %e% 'col' , 1),
			edge.lwd =  rep(0.01, max(valid.eids(net))), #0.05 + net %e% 'fb',
			edge.curve = 0.01,
			displayisolates=T, pad = 0
			)
}

plotnet2 <- function(net, ...){
	plot.network(net, #mode='circle',
			vertex.col = alpha(net %v% 'col', 0.7),
			# label = network.vertex.names(net),
			# label.cex= 1,
			main = net %n% 'name', col.main = "gray44", cex.main = 1.2,
			vertex.border = 0,
			usecurve=T,
			vertex.cex= 2 + scale(net %v% 'fb'),
			label.pos= 5,
			edge.col= alpha(net %e% 'col' , 1),
			edge.lwd =  0.01 * net %e% 'fb',
			edge.curve = 0.01,
			displayisolates=T, pad = 0 # no need of pad for labels
			)
		}
## A function to create the network, add polarity and cycles / feedbacks as edge attributes
## J161105: Edge attributes are tricky to set because once the network is created the ordering of edges is lost and I cannot find the default order to set the right values. Reading the help of 'loading.attributes' I found that when declared as edgelist one can add attributes directly on the dataframe.
rs.net <- function (dat, i){
	# filter dataset
	dat <- filter(dat, Regime.Shift == levels(dat$Regime.Shift)[i],
	 Polarity == 1 | Polarity == -1)
	#dat <- droplevels(dat)
	# This ordering step is necessary to make sure polarity and other attributes are assigned correctly
	# dat <- dat[order(dat$Tail, partial = dat$Head, decreasing = F),]
	# tab <- table(dat$Tail, dat$Head, dat$Polarity) # tab is an array of tables
		# dimnames(tab) [[3]] "-1"   "-0.5" "0.5"  "1"
		# v <- as.matrix(tab[,,1]*-1) + as.matrix(tab[,,2])
	# build network
		rs.x <- network(select(dat, Tail, Head, Polarity, col), directed = T, ignore.eval=FALSE, matrix.type = 'edgelist')
	# add polarity to edges: Outated, the way I create the network includes already the polarities by using ignore.eval = F. Edge color is also set on the network creation line.
		# rs.x %e% 'polarity' <- dat$Polarity
		# set.edge.value(rs.x, 'polarity', value = as.matrix(v))
		# rs.x %e% 'col' <- ifelse(rs.x %e% "Polarity" == -1, 'red', 'blue')
	# add cycles to nodes and edges.
		fb.sum <- kcycle.census(rs.x, maxlen=network.size(rs.x), mode='digraph',	tabulate.by.vertex=T, cycle.comembership='sum')
		# number of cycles per nodes
		rs.x %v% 'fb' <-  diag(fb.sum$cycle.comemb)
		# number of cycles per edge
		rs.x %e% 'fb' <- as.sociomatrix(rs.x) * fb.sum$cycle.comemb
		#J161106: Note that cycle.comemb is a matrix with comemberships, so two nodes that are not connected in the network can belong to the same cycles. That's why I multiply by the adjacency matrix, to isolate only the edges. cycle.comemb can be used later for discovery of inconvenient feedbacks.
	## add vertex attributes
		rs.x %v% 'col' <- ifelse(colSums(fb.sum$cycle.count)[-1] == 0, "#E41A1C","#8DA0CB") # "#FFD92F"
		rs.x %n% 'name' <- levels(dat$Regime.Shift)[i]
	return(rs.x)
}

```

## Introduction

Regime shifts occur across a wide range of social-ecological systems, they are hard to predict and difficult to reverse [@Boettiger:2013bm; @Hastings:2010p5336], while producing long term shifts in the availability of ecosystems services [@Carpenter:2009jr]. A regime shift means that a system has moved from one stability domain to another, implying a shift from one set of dominating processes and structures to another set [@MAY:1977p3426; @Holling:1973p6861; @Scheffer:2001uu; @Anonymous:2004bq]. Changes in a key variable (e.g. temperature in coral reefs) often makes a system more susceptible to shifting regimes when exposed to shock events (e.g. hurricanes) or the action of external drivers [@Scheffer:2012cta]. Over 30 different regime shifts in social-ecological systems have been documented [@Biggs:2015iha], and similar non-linear dynamics are seen across societies, finance, language, neurological diseases, or climate [@Sole:2011us; @Scheffer:2009wl]. As humans increase their pressure on the planet, regime shifts are likely to occur more often and severely [@Rocha:2015du].

A key challenge for science and practice is that regime shifts, in addition to being hard to predict, can potentially lead to subsequent regime shifts. A variety of cascading regime shifts have been reported (See Table S1). For example, eutrophication is often reported as a preceding regime shift to hypoxia or dead zones in coastal areas [@Diaz:2008p199]. Similarly, hypoxic events have been reported to affect the resilience of coral reefs to warming and other stressors in the tropics [@Altieri:2017bl]. If, why and how a regime shift somewhere in the world could affect the occurrence of another regime shift, however, remains largely an open question and a key frontier of research  [@Liu:2015go; @Hughes:2013cv] that we here aim to address.

Research on regime shifts is often confined to well-defined branches of science, reflecting empirical, theoretical [@Carpenter2003rsi] or predictive approaches [@Scheffer:2012cta; @Scheffer:2009p4449]. These approaches require a deep knowledge of the causal structure of the of system or a high quality of spatio-temporal data. Hence research on regime shifts has generally focused on the analysis of individual types of regime shifts rather than potential interactions across systems. This paper takes another approach and instead explores potential interactions among a large set of regime shifts.  We propose and investigate two types of interconnections: domino effects and hidden feedbacks. Domino effects occur when the feedback processes of one regime shifts affect the drivers of another, creating a one-way dependency [@Rocha:2010vv; @Hughes:2013cv; @Scheffer:2012cta]. Hidden feedbacks rise when two regime shifts combined generate new (not previously identified) feedbacks [@Liu:2015go; @Rocha:2010vv]; and if strong enough, they could amplify or dampen the coupled dynamics. Furthermore, we contrast these cascading effects, where the occurrence of a regime shift give rise to subsequent regime shifts, with the potentially multiplying albeit different effect of two regime shifts being caused by common drivers. Sharing drivers is likely to increase correlation in time or space among regime shifts, but not necessarily interdependence [@Hughes:2013cv; @Rocha:2015du].

## Hypotheses of cascading effects

Domino effects occur when a variable that belongs to a feedback mechanism in a regime shift acts as driver in another. A feedback mechanism is a self-amplifying or dampening process characterized by a pathway of causal processes that return to its origin creating a cycle. Theory often treats drivers as slow variables, which assumes that their change are relatively slower than changes in state variables [@Walker:2012bx; @Dekker:2018jk]. Therefore, we expect that domino effects will be mostly dominated by connections from regime shifts that occur at larger spatial scales with slower temporal dynamics to regime shifts that operate at smaller spatial scales with faster temporal dynamics. Conversely, we expect that hidden feedbacks will occur when scales match (both in space and time), because for a new feedback to emerge they need to be somewhat aligned in the scale at which the process operate. Additionally, we expect that drivers sharing is more context-specific; in this case, regime shifts occurring in similar ecosystem types or land uses will be subject to relatively similar sets of drivers, increasing the likelihood of driver sharing.

Discovering how regime shifts might be interconnected requires a method for studying patterns in relational data. We analysed regime shifts as networks of drivers and feedback processes underlying their dynamics. These directed signed graphs allow us to explore driver co-occurrence, directional pathways and emergent feedback cycles of coupled regime shift networks (See SM Methods). The empirical basis for our investigation draws from the [regime-shifts database](www.regimeshifts.org)[@Biggs:2015iha], to our knowledge the largest online repository of regime shifts in social-ecological systems (Fig S2, SM Methods). It offers syntheses of over $30$ types of regime shifts and $> 300$ case studies based on literature review of $> 1000$ scientific papers [@Biggs:2015iha]. The database consistently describes regime shifts in terms of their alternative regimes, drivers, feedback mechanisms, impacts on ecosystem services, and management options. It provides a set of $75$ categorical variables (Table S2) about impacts, scales, and evidence types [@Biggs:2015iha] that we used to test our hypotheses. Regime shifts are also described using consistently coded causal-loop diagrams as a summary of the drivers and underlying feedbacks of each regime shift (Fig S1). We converted the causal diagram for each regime shift into a network by creating the adjacency matrix $A$, where $A_{i,j}$ is $1$ if there is a connection or zero otherwise. A link between two nodes in these networks means that there is at least a scientific paper reviewed in the database providing some evidence for such causal relationship [@Rocha:2015du]. Link sign $w_{i,j}$ represents a link polarity taking $-1$ if the relationship is expected to be negative, or $1$ when positive (SM Methods). Based on the signed graphs, we merged pairs of regime-shifts networks and created three response variables matrices that correspond to each of the cascading effects (Fig 1).

We tested our three hypotheses using as response variable for _drivers sharing_ the number of drivers shared, for _domino effects_ the number of directed pathways that connect two regime shifts, and for _hidden feedbacks_ it is the number of k-cycles (where $k$ denotes cycle length) that emerge on the joined network that do not exist on the separate causal networks (Fig. \ref{fig:Fig1}, SM Methods). Each of these response variables are matrices that can be represented as weighted networks in our statistical framework, in which nodes are regime shifts and the link depends on the cascading effect described (Fig. \ref{fig:Fig1}). Thus, our research question can be rephrased as 'What is the likelihood of a link between regime shifts in the response variable network, and what features change this likelihood?' As explanatory variables we use the regime-shift database categorical variables ($N=75$, Table S2, see SM methods for processing of variables). We focused on how similar two regime shifts are based on the categorical variables they share, and how the similarity increases or not the likelihood of having a link. We analyzed patterns of connections using exponential random graph models (SM Method). All these networks contain weighted links of count data; therefore, the specification for the models have a Poisson reference distribution [@Krivitsky:2012uo].

```{r Fig1, cache = TRUE, echo = FALSE, error=FALSE, warning=FALSE, message=FALSE, fig.height = 3, fig.width = 4, fig.align = 'center', fig.cap = "Minimal examples of the cascading effects. We merged pairs of regime shifts causal networks and created a response variable matrix that accounted for drivers shared, domino effects, or hidden feedbacks for all pair-wise combinations of regime shifts. For example, for drivers sharing two minimal regime shifts are depicted as causal diagrams, drivers are coloured red and variables inside feedbacks purple. The joint network is represented as a 2-mode network which allows us to study the co-occurrence of drivers across regime shifts. The response variable matrix counts the drivers shared by all pair-wise combinations of regime shifts. In the example of a domino effect two regime shifts are joined together where driver c in regime shift 2 is part of a feedback process in regime shift 1, creating a one-way dependency (orange colored link) between the two regime shifts. The response variable matrix counts all the one-way causal pathways between pair-wise combinations of regime shifts. In the example of a hidden feedback, two minimal regime shifts when joined together give rise to a new unidentified feedback of length 4 (orange circular pathway). The response variable matrix counts all hidden feedbacks that arise when merging all pair-wise combinations of regime shifts. Labelled matrices of the resulting response variables are available in the supplementary material.", dev = "pdf", dpi = 300, dev.args = list(pointsize = 6)}

# load mini data
mini_dat <- readr::read_csv2("~/Documents/Projects/Cascading Effects/minimal_example_cld_cascading_effects.csv")

# setwd("~/Documents/Projects/Cascading Effects/Figures")

# mini_dat %>% filter (Regime.Shift == 'rs1') %>%
#     select(tail, head, color) %>%
#     # network(directed = T, ignore.eval=FALSE, matrix.type = 'edgelist') %>%
#     # ggnet2(edge.color = "color", arrow.size = 1) # no curved edges, I need them
#     igraph::graph_from_data_frame(directed = TRUE) %>%
#     igraph::plot.igraph(edge.curved = c(0,0,0.5,0.5),
#         vertex.color = alpha(c(rep("red", 2), rep("purple",2)), 0.7 ),
#         vertex.frame.color = NA, vertex.label.color = "grey84",
#         layout = matrix(c(rep(0,4), 4,1,3,2), ncol = 2, nrow = 4),
#         main = "regime shift 1")


# quartz(width = 6, height = 4, pointsize = 7)
# par(mfrow = c(3,4), mar = c(2,2,2,2)) # layout(matrix(1:12,4,3, byrow=T))
# plot.new()
# # grid.newpage() # I need this line to plot on quartz, but not on markdown pdf.
# pushViewport(viewport(layout = grid.layout(3,4)))
#
# ## first row 2 clds
# pushViewport(viewport(layout.pos.row=1, layout.pos.col=1))
# par(fig = gridFIG(), new = TRUE)
# quartz(width = 2, height=2, pointsize = 6)
# mini_dat %>% filter (Regime.Shift == 'rs1') %>%
#     select(tail, head, color) %>%
#     # network(directed = T, ignore.eval=FALSE, matrix.type = 'edgelist') %>%
#     # ggnet2(edge.color = "color", arrow.size = 1) # no curved edges, I need them
#     igraph::graph_from_data_frame(directed = TRUE) %>%
#     igraph::plot.igraph(edge.curved = c(0,0,0.5,0.5), edge.arrow.size = 0.5, edge.width = 0.5, vertex.size = 25, vertex.label.cex = 2,
#         vertex.color = alpha(c(rep("red", 2), rep("purple",2)), 0.7 ),
#         vertex.frame.color = NA, vertex.label.color = "white",
#         layout = layout_with_kk, margin = c(rep(-0.45,4))
#          #matrix(c(rep(1,4), 4,1,3,2), ncol = 2, nrow = 4),
#         )
# quartz.save("fig1a.png", type = "png", width = 2, height=2, pointsize = 6, dpi = 300, bg = "white", canvas = "white")
# title('a)', adj = 0, cex=5)
# popViewport()
#
# pushViewport(viewport(layout.pos.row=1, layout.pos.col=2))
# par(fig = gridFIG(), new = TRUE)
# # quartz(width = 2, height=2, pointsize = 6)
# mini_dat %>% filter (Regime.Shift == 'rs2') %>%
#     select(tail, head, color) %>%
#     igraph::graph_from_data_frame(directed = TRUE) %>%
#     igraph::plot.igraph(edge.curved = c(0,0.5,0.5), edge.arrow.size = 0.5,edge.width = 0.5, vertex.size = 25, vertex.label.cex = 2,
#         vertex.color = alpha(c(rep("red", 1), rep("purple",2)), 0.7 ),
#         vertex.frame.color = NA, vertex.label.color = "white",
#         layout = layout_with_kk , margin = c(rep(-0.45,4))
#         #matrix(c(rep(1,3), 3,2,1), ncol = 2, nrow = 3),
#         )
# quartz.save("fig1b.png", type = "png", width = 2, height=2, pointsize = 6, dpi = 300, bg = "white", canvas = "white")
# popViewport()

#
# pushViewport(viewport(layout.pos.row=1, layout.pos.col=3))
# par(fig = gridFIG(), new = TRUE)
# # quartz(width = 2, height=2, pointsize = 6)
# mini_dat %>% filter (RS_joined == 'rs1_2') %>%
#     select(tail, Regime.Shift, color) %>%
#     # network(directed = T, ignore.eval=FALSE, matrix.type = 'edgelist') %>%
#     # ggnet2(edge.color = "color", arrow.size = 1) # no curved edges, I need them
#     igraph::graph_from_data_frame(directed = TRUE) %>%
#     igraph::plot.igraph(edge.curved = FALSE, vertex.shape = c("circle", "circle", "square", "square"),
#         vertex.color = alpha(c(rep("red", 2), rep("blue",2)), 0.7 ), vertex.size = 30, vertex.label.cex = 2,
#         vertex.frame.color = NA, vertex.label.color = "white",
#         edge.width = 0.5, edge.arrow.size = 0.5,
#         layout = matrix(c(1,1,2,2, 2,1,2,1), ncol = 2, nrow = 4),
#         margin = c(rep(-0.45,4))
#     )
# quartz.save("fig1c.png", type = "png", width = 2, height=2, pointsize = 6, dpi = 300, bg = "white", canvas = "white")
# popViewport()


m1 <- ggplot(
    data = as.sociomatrix(x, "paths") %>% as_tibble() %>% mutate(tail = rownames(as.sociomatrix(x))) %>%
        gather(key = head, value = paths,  1:30)  %>%
        mutate(tail = as.factor(tail), # %>% forcats::fct_rev(),
               head = as.factor(head) %>% forcats::fct_rev()),
    aes(tail, head)) +
    geom_tile(aes(fill = paths), show.legend = FALSE) + ylab("") + xlab("") +
    scale_fill_gradient2(low = "#FFA50080", mid = "gray84" ,high = "#0000FF80",
                         midpoint = 0, na.value = "grey50",
                         guide = guide_colorbar(title = " ", barheight = 3, barwidth = 0.3)) +
    theme_light (base_size=4) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank(),
          legend.position = c(0.9,0.5), legend.direction = "vertical")

# pushViewport(viewport(layout.pos.row=1, layout.pos.col=4))
# par(fig = gridFIG(), new = TRUE)
# print(m1, newpage = FALSE)
# popViewport()

## second panel
# pushViewport(viewport(layout.pos.row=2, layout.pos.col=1))
# par(fig = gridFIG(), new = TRUE)
# quartz(width = 2, height=2, pointsize = 6)
# mini_dat %>% filter (Regime.Shift == 'rs3') %>%
#     select(tail, head) %>%
#     igraph::graph_from_data_frame(directed = TRUE) %>%
#     igraph::plot.igraph(edge.curved = FALSE,
#         vertex.color = alpha(c("red", rep("purple",3), "red"), 0.7 ), vertex.size = 25,  vertex.label.cex = 2,
#         vertex.frame.color = NA, vertex.label.color = "white",
#         edge.arrow.size = 0.5, edge.width = 0.5, margin = c(rep(-0.45,4))
#         # layout = matrix(c(1,1,0.5,1,1, 4,3,2.5,2,1), ncol = 2, nrow = 5) ,
#         )
# quartz.save("fig1d.png", type = "png", width = 2, height=2, pointsize = 6, dpi = 300, bg = "white", canvas = "white")
# title ('b)', adj = 0, cex = 5)
# popViewport()

# pushViewport(viewport(layout.pos.row=2, layout.pos.col=2))
# par(fig = gridFIG(), new = TRUE)
# mini_dat %>% filter (Regime.Shift == 'rs4') %>%
#     select(tail, head) %>%
#     igraph::graph_from_data_frame(directed = TRUE) %>%
#     igraph::plot.igraph(edge.curved = FALSE,
#         vertex.color = alpha(c("red", rep("purple",4)), 0.7 ), vertex.size = 25,
#         vertex.frame.color = NA, vertex.label.color = "white",
#         edge.width = 0.5, edge.arrow.size = 0.5, vertex.label.cex = 2,
#         margin = c(rep(-0.45,4))
#         #layout = matrix(c(0,0,-1,0,1, 3,2,1,0,1), ncol = 2, nrow = 5) ,
#     )
# quartz.save("fig1e.png", type = "png", width = 2, height=2, pointsize = 6, dpi = 300, bg = "white", canvas = "white")
# popViewport()

# pushViewport(viewport(layout.pos.row=2, layout.pos.col=3))
# par(fig = gridFIG(), new = TRUE)
# mini_dat %>% filter (RS_joined == 'rs3_4') %>%
#     select(tail, head, color) %>%
#     igraph::graph_from_data_frame(directed = TRUE) %>%
#     igraph::plot.igraph(edge.curved = FALSE, edge.arrow.size = 0.5,
#         vertex.color = alpha(c("red","gray","red", "gray", "red", rep("gray",4)), 0.7 ),
#         edge.width = 0.5,vertex.size = 25, vertex.label.cex = 2,
#         vertex.frame.color = NA, vertex.label.color = "white",
#         margin = c(rep(-0.45,4))
#         #layout = matrix(c(0,0,1,0,0,1,2,3,2,  4,3,2.5,2,1, 2.5, 1, 2.5, 3), ncol = 2, nrow = 9) ,
#     )
# quartz.save("fig1f.png", type = "png", width = 2, height=2, pointsize = 6, dpi = 300, bg = "white", canvas = "white")
# popViewport()

m2 <- ggplot(
    data = out %>%
         mutate(Tail = as.factor(Tail), # %>% forcats::fct_rev(),
               Head = as.factor(Head) %>% forcats::fct_rev()),
    aes( Head, Tail)) +
    geom_tile(aes(fill = weight), show.legend = FALSE) + ylab("") + xlab("") +
    scale_fill_gradient(high = "red", low = "gray84", na.value = "grey50",
                         guide = guide_colorbar(title = " ", barheight = 3, barwidth = 0.3)) +
    theme_light(base_size=4) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank(),
          legend.position = c(0.9,0.5), legend.direction = "vertical")

# pushViewport(viewport(layout.pos.row=2, layout.pos.col=4))
# par(fig = gridFIG(), new = TRUE)
# print(m2, newpage = FALSE)
# popViewport()




## third row

# pushViewport(viewport(layout.pos.row=3, layout.pos.col=1))
# par(fig = gridFIG(), new = TRUE)
# mini_dat %>% filter (Regime.Shift == 'rs5') %>%
#     select(tail, head) %>%
#     igraph::graph_from_data_frame(directed = TRUE) %>%
#     igraph::plot.igraph(edge.curved = c(0,0.5,0.5), edge.arrow.size = 0.5,
#                         edge.width = 0.5,
#         vertex.color = alpha(c("red", rep("purple",2)), 0.7 ), vertex.size = 25,
#         vertex.frame.color = NA, vertex.label.color = "white",
#         vertex.label.cex = 2, margin = c(rep(-0.45,4)),
#         layout = layout_with_kk #matrix(c(1,1,1, 3,2,1), ncol = 2, nrow = 3) ,
#         )
# quartz.save("fig1g.png", type = "png", width = 2, height=2, pointsize = 6, dpi = 300, bg = "white", canvas = "white")
# title ('c)', adj = 0, cex = 5)
# popViewport()
#
# pushViewport(viewport(layout.pos.row=3, layout.pos.col=2))
# par(fig = gridFIG(), new = TRUE)
# mini_dat %>% filter (Regime.Shift == 'rs6') %>%
#     select(tail, head) %>%
#     igraph::graph_from_data_frame(directed = TRUE) %>%
#     igraph::plot.igraph(edge.curved = c(0,0.5,0.5), edge.arrow.size = 0.5, edge.width = 0.5, vertex.label.cex = 2,
#         vertex.color = alpha(c("red", rep("purple",2)), 0.7 ), vertex.size = 25,
#         vertex.frame.color = NA, vertex.label.color = "white",
#         layout = layout_with_kk , margin = c(rep(-0.45,4))
#         #matrix(c(1,1,1, 1,2,3), ncol = 2, nrow = 3),
#         )
# quartz.save("fig1h.png", type = "png", width = 2, height=2, pointsize = 6, dpi = 300, bg = "white", canvas = "white")
# popViewport()
#
# pushViewport(viewport(layout.pos.row=3, layout.pos.col=3))
# par(fig = gridFIG(), new = TRUE)
# mini_dat %>% filter (RS_joined == 'rs5_6') %>%
#     select(tail, head, color) %>%
#     igraph::graph_from_data_frame(directed = TRUE) %>%
#     igraph::plot.igraph(edge.curved = -0.8, edge.arrow.size = 0.5,
#         vertex.color = alpha(c("red","purple","red", "purple"), 0.7 ),
#         edge.width = 0.5, vertex.size = 25,
#         vertex.frame.color = NA, vertex.label.color = "white",
#         vertex.label.cex = 2, margin = c(rep(-0.45,4))
#         #layout = matrix(c(0,0,1,0,0,1,2,3,2,  4,3,2.5,2,1, 2.5, 1, 2.5, 3), ncol = 2, nrow = 9) ,
#         )
# quartz.save("fig1i.png", type = "png", width = 2, height=2, pointsize = 6, dpi = 300, bg = "white", canvas = "white")
# popViewport()

m3 <- ggplot(data = df_inc,  #%>%
#          mutate(Tail = as.factor(Tail), # %>% forcats::fct_rev(),
#                Head = as.factor(Head) %>% forcats::fct_rev()),
         aes(Tail, Head)) +
    geom_tile(aes(fill = log(inc)), show.legend = FALSE) + ylab("") + xlab("") +
    scale_fill_gradient(low = "#FFA50080", high = "#0000FF80", na.value = "grey50",
                        guide = guide_colorbar(title = "[log]", barheight = 3, barwidth = 0.3)) +
    theme_light(base_size=4) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank(),
          legend.position = c(0.9,0.5), legend.direction = "vertical")


# pushViewport(viewport(layout.pos.row=3, layout.pos.col=4))
# par(mar=c(2,2,2,2))
# print(m3, newpage = F)
# popViewport()

# detach(package:igraph)

# quartz.save(file="methods_scheme.png", width=7, height=7, pointsize = 7, dpi = 300)

### Attempt with GGally
## First recover the png networks into ggplots objects.
p1 <- ggplot(data = data_frame(x = 0, y= 0), aes(x,y)) + geom_blank() +
    theme_void() +
    annotation_custom(
        grob = grid::rasterGrob( image = readPNG(
            "~/Documents/Projects/Cascading Effects/Figures/fig1a.png"), interpolate = TRUE),
        xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf
        )

p2 <- ggplot(data = data_frame(x = 0, y= 0), aes(x,y)) + geom_blank() +
    theme_void() +
    annotation_custom(
        grob = grid::rasterGrob( image = readPNG(
            "~/Documents/Projects/Cascading Effects/Figures/fig1b.png"), interpolate = TRUE),
        xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf
        )

p3 <- ggplot(data = data_frame(x = 0, y= 0), aes(x,y)) + geom_blank() +
    theme_void() +
    annotation_custom(
        grob = grid::rasterGrob( image = readPNG(
            "~/Documents/Projects/Cascading Effects/Figures/fig1c.png"), interpolate = TRUE),
        xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf
        )
p4 <- ggplot(data = data_frame(x = 0, y= 0), aes(x,y)) + geom_blank() +
    theme_void() +
    annotation_custom(
        grob = grid::rasterGrob( image = readPNG(
            "~/Documents/Projects/Cascading Effects/Figures/fig1d.png"), interpolate = TRUE),
        xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf
        )

p5 <- ggplot(data = data_frame(x = 0, y= 0), aes(x,y)) + geom_blank() +
    theme_void() +
    annotation_custom(
        grob = grid::rasterGrob( image = readPNG(
            "~/Documents/Projects/Cascading Effects/Figures/fig1e.png"), interpolate = TRUE),
        xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf
        )

p6 <- ggplot(data = data_frame(x = 0, y= 0), aes(x,y)) + geom_blank() +
    theme_void() +
    annotation_custom(
        grob = grid::rasterGrob( image = readPNG(
            "~/Documents/Projects/Cascading Effects/Figures/fig1f.png"), interpolate = TRUE),
        xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf
        )
p7 <- ggplot(data = data_frame(x = 0, y= 0), aes(x,y)) + geom_blank() +
    theme_void() +
    annotation_custom(
        grob = grid::rasterGrob( image = readPNG(
            "~/Documents/Projects/Cascading Effects/Figures/fig1g.png"), interpolate = TRUE),
        xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf
        )

p8 <- ggplot(data = data_frame(x = 0, y= 0), aes(x,y)) + geom_blank() +
    theme_void() +
    annotation_custom(
        grob = grid::rasterGrob( image = readPNG(
            "~/Documents/Projects/Cascading Effects/Figures/fig1h.png"), interpolate = TRUE),
        xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf
        )

p9 <- ggplot(data = data_frame(x = 0, y= 0), aes(x,y)) + geom_blank() +
    theme_void() +
    annotation_custom(
        grob = grid::rasterGrob( image = readPNG(
            "~/Documents/Projects/Cascading Effects/Figures/fig1i.png"), interpolate = TRUE),
        xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf
        )


plot_list <- list(p1,p2,p3, m1, p4,p5,p6,m2, p7,p8,p9,m3)
pp <- ggmatrix(
    plot_list, ncol = 4, nrow = 3,
    xAxisLabels = c("regime shift 1", "regime shift 2", "joint regime shifts", "response variable"),
    yAxisLabels = c("drivers sharing", "domino effects", "hidden feedbacks"),
    byrow = TRUE, showAxisPlotLabels = FALSE, switch = 'y'
)

# quartz(width = 4, height =3, pointsize = 6)
pp + theme(strip.text = element_text(size = 6))
# ggsave("Cascading_Fig1.png")
```

## Driver sharing

```{r Fig2, cache = TRUE, echo = FALSE, error=FALSE, results = 'hide', warning=FALSE, message=FALSE, fig.height = 2.5, fig.width = 5, dev.args = list(pointsize= 6), fig.align='center', fig.cap = 'Driver sharing. The distribution of drivers shared per regime shift (a) with respect to the number of drivers each one has (black points) shows that regime shifts in aquatic environments tend to have and share more drivers. (b) shows the drivers most shared. WAIS abbreviates West Antarctica Ice Sheet collapse.', dev = "pdf", dpi = 300}

## note that from the ergms script, x is the one mode network of the bipartite network
#x <- mode.1(bip1)[[2]] # x is the regime shifts one-mode network
z <- mode.1(bip1)[[1]]
# and
# bip.edgelist <- bind_rows(bip.edgelist)
# bipmat <- as.matrix(table(bip.edgelist))

df_rs_type <- tibble(
    tail = rsdb$name,
    type = c("Aquatic", "Earth", "Aquatic", "Terrestrial", "Terrestrial", "Aquatic",
             "Terrestrial", "Aquatic", "Aquatic", "Terrestrial", "Aquatic", "Earth",
             "Aquatic", "Aquatic", "Land-water interface", "Aquatic",
             "Aquatic", "Earth", "Land-water interface", "Aquatic","Land-water interface",
             "Land-water interface", "Aquatic","Terrestrial","Terrestrial","Terrestrial",
             "Earth","Land-water interface", "Terrestrial", "Earth")
)

g1 <- ggplot(
    data = as.sociomatrix(x, "paths") %>% as_tibble() %>% mutate(tail = rownames(as.sociomatrix(x))) %>%
        gather(key = head, value = paths,  1:30) %>% left_join(df_rs_type) %>%
        mutate(tail = as.factor(tail) ) %>%
        mutate(tail = forcats::fct_reorder(tail, paths, fun = sum, .desc = FALSE)),
    aes(tail, paths, fill = type, color = type)) +
    geom_boxplot(outlier.alpha = 0.5, alpha=0.5,
                 outlier.size = 0.8, size = 0.1) +
    geom_point(
        data = bip.edgelist %>% mutate(value = 1) %>%
            group_by(rs) %>%
            summarize(paths = sum(value)) %>% left_join(df_rs_type, by = c("rs" = "tail")) ,
        aes(rs, paths), color = "black", size = 1.5, show.legend = FALSE
    ) +
    scale_fill_manual("Ecosystem type",values = c("blue", "purple", "red","orange")) +
    scale_color_manual("Ecosystem type",values = c("blue", "purple", "red","orange")) +
    coord_flip() +  xlab("regime shifts") + ylab("number of drivers") + ggtitle("A") +
    theme_minimal(base_size = 6) +
    theme(legend.position = c(0.8, 0.2),
          legend.background = element_rect(fill = "white", linetype = 0),
          legend.text = element_text(size = 3), legend.title = element_text(size = 3), legend.key.size = unit(1, 'line'))

g2 <- ggplot(
    data = as.sociomatrix(z, "paths") %>% as_tibble() %>% mutate(tail = rownames(as.sociomatrix(z))) %>%
        gather(key = head, value = paths,  1:79) %>%
        group_by(tail) %>% filter(mean(paths) >  1 ) %>% ungroup() %>%
        mutate(tail = as.factor(tail)) %>%
        mutate(tail = forcats::fct_reorder(tail, paths, fun = sum, .desc = FALSE)),
    aes(tail, paths)) +
    geom_boxplot(fill = alpha("grey", 0.7), color = "grey", outlier.alpha = 0.5,
                 outlier.size = 0.8, size = 0.1) +
    # geom_point(
    #     data = bip.edgelist %>% mutate(value = 1) %>%
    #         group_by(drivers) %>%
    #         summarize(paths = sum(value)),
    #     aes(drivers, paths), color = "purple"
    # ) +
    coord_flip() +  xlab("most shared drivers\n [mean > 1]") + ylab("number of regime shifts") +  ggtitle("B") +
    theme_minimal(base_size = 6)

m1 <- ggplot(
    data = as.sociomatrix(x, "paths") %>% as_tibble() %>% mutate(tail = rownames(as.sociomatrix(x))) %>%
        gather(key = head, value = paths,  1:30)  %>%
        mutate(tail = as.factor(tail), # %>% forcats::fct_rev(),
               head = as.factor(head) %>% forcats::fct_rev()),
    aes(tail, head)) +
    geom_tile(aes(fill = paths)) + ylab("") + xlab("") + ggtitle("Drivers sharing") +
    scale_fill_gradient(low = "gray84" ,high = "#0000FF80", na.value = "grey50",
                         guide = guide_colorbar("shared drivers", barheight = 0.7)) +
    theme_light (base_size = 6) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5 ),
          legend.position = "bottom")

## Heatmap with ggplot
m2 <- ggplot(
    data = out %>%
         mutate(Tail = as.factor(Tail) %>% forcats::fct_rev(),
               Head = as.factor(Head)), #%>% forcats::fct_rev()),
    aes( Head, Tail)) +
    geom_tile(aes(fill = weight)) + ggtitle("Domino effects") +
    ylab("Independent regime shift") + xlab("Dependent regime shift") +
    scale_fill_gradient(high = "red", low = "gray84", na.value = "grey50",
                         guide = guide_colorbar("domino effects", barheight = 0.7))  +
    theme_light(base_size = 6) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5 ),
          legend.position = "bottom")

df_domino <- out %>%
        mutate(Tail = as.factor(Tail), Head = as.factor(Head)) %>%
        filter(weight > 0) %>% pull(Tail) %>% fct_count() %>% rename(outdegree = n)

df_domino <- left_join(df_domino,
        out %>%
        mutate(Tail = as.factor(Tail), Head = as.factor(Head)) %>%
        filter(weight > 0) %>% pull(Head) %>% fct_count() %>% rename(indegree = n)
)

df_domino <- left_join(df_domino,
    out %>% group_by(Tail) %>%
        summarize(out_avg = mean(weight), out_max = max(weight)) %>%
        rename(f = Tail)
)

df_domino <- left_join(df_domino,
    out %>% group_by(Head) %>%
        summarize(in_avg = mean(weight), in_max = max(weight)) %>%
        rename(f = Head)
)

df_poly <- data_frame(
    id = rep(factor(c("1", "2")), each = 3),
    x = c(0,0,10, 0,25,25),
    y = c(0,25,25, 0,10,0),
    value = as.factor(c(rep(alpha("orange", 0.4),3), rep(alpha("green", 0.4),3)))
)

g3 <- ggplot(
    data = df_domino %>% left_join (df_rs_type, by = c("f" = "tail")) ,
    aes(y = outdegree, x = indegree)) +
    geom_point( aes(color = type), size = 1.5, show.legend = TRUE) +
    # geom_errorbar(aes(ymin = out_avg, ymax = out_max, color = type)) +
    # geom_errorbarh(aes(xmin = in_avg, xmax = in_max, color = type)) +
    geom_text_repel(
        data = df_domino %>% filter(out_max > 3 | in_max > 3),
        aes(label = f), size = 1.5) +
    geom_polygon(data = df_poly,  mapping = aes(x, y, group = id, fill = value), show.legend = FALSE, position = "identity", stat = "identity", inherit.aes = FALSE) +
    scale_fill_manual(guide = "none", values = c(alpha("orange", 0.2),alpha("green", 0.2))) +
    scale_color_manual("Ecosystem type",values = c("blue", "purple", "red","orange")) +
    ggtitle("A") + coord_equal() +
    labs(x = "indegree\n [dependent regime shifts]", y = "outdegree\n [independent regime shifts]") +
    theme_minimal(base_size = 6) +
    theme(legend.position = c(0.8, 0.8),
          legend.background = element_rect(fill = "white", linetype = 0),
          legend.text = element_text(size = 5), legend.title = element_text(size =5)
          )


g4 <- ggplot(
    out %>% filter(weight > 0) %>%
        pull(driv2feed) %>% stringr::str_split(pattern = ", ") %>%
        unlist() %>% as_tibble() %>% rename(driver = value) %>%
        group_by(driver) %>% summarize(n = n()) %>% ungroup() %>%
        mutate(driver = as_factor(driver)) %>%
        mutate(driver = fct_reorder(driver, n, .desc = FALSE)) %>%
        filter(n > 1),
    aes(driver, n)) +
    geom_bar(stat = "identity") + coord_flip() + ylab("number of domino effects") + xlab("key variables")+
    ggtitle('B') + theme_minimal(base_size = 6)



## Heatmap with ggplot
m3 <- ggplot(
    data = df_inc %>%
         mutate(Tail = as.factor(Tail) %>% forcats::fct_rev(),
               Head = as.factor(Head)), #%>% forcats::fct_rev()),
    aes( Head, Tail)) +
    geom_tile(aes(fill = log(inc)))  + ggtitle("Hidden feedbacks") +
    ylab("") + xlab("") +
    scale_fill_gradient(low = "#FFA50080", high = "#0000FF80", na.value = "grey50",
                        guide = guide_colorbar("hidden feedbacks [log]", barheight = 0.7)) +
    theme_minimal(base_size = 6) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5 ),
          legend.position = "bottom")  +
    inset(
        grob = ggplotGrob(
            ggplot(data = df_inc, aes(inc)) +
                geom_histogram() + xlab('Hidden feedbacks') +
                theme_light(base_size = 6) ) , xmin = 0, xmax =15 , ymin = 0, ymax = 15)

## I need to make the matrix symmetric so it does count the degrees correctly.
df_inc2 <- data.frame(inc = inc, Head = levels(dat$Regime.Shift)[key[1,]], Tail = levels(dat$Regime.Shift)[key[2,]])

df_inc3 <- bind_rows(df_inc, df_inc2)

g5 <- ggplot(
    data = df_inc3 %>%
        mutate(Tail = as.factor(Tail), Head = as.factor(Head)) %>%
        left_join (df_rs_type, by = c("Tail" = "tail")) %>%
        mutate(Tail = fct_reorder(Tail, inc, fun = mean, .desc = FALSE )) %>% filter(inc > 0)  ,
    aes(Tail, inc, color = type, fill = type)) +
    geom_boxplot( outlier.alpha = 0.5, alpha = 0.5,
                 outlier.size = 0.8, show.legend = TRUE, size = 0.1) +
    # geom_point(
    #     data = df_inc3 %>%
    #         group_by(Tail) %>%
    #         summarize(outdegree = sum(inc > 0)),
    #     aes(Tail, outdegree), color = "orange", size = 1.5, shape = 12
    # ) +
    scale_y_log10()+
    scale_fill_manual("Ecosystem type",values = c("blue", "purple", "red","orange")) +
    scale_color_manual("Ecosystem type",values = c("blue", "purple", "red","orange")) +
    coord_flip() +
    xlab("regime shifts") + ylab("hidden feedbacks") + ggtitle("A") +
    theme_minimal(base_size = 6)+
    theme(legend.position = "right", #c(0.85, 0.2),
          legend.background = element_rect(fill = "white", linetype = 0),
          legend.text = element_text(size = 4), legend.title = element_text(size = 3)
          )

z <- bind_rows(out_dat)

z <- gather(z,`Inconvenient`,`Expected`, key = Feedbacks, value = count)

z$Feedbacks <- factor(z$Feedbacks)
levels(z$Feedbacks)[2] <- "Hidden"

## J171213: Alternative to g6
 brain <- network(select(dat, Tail, Head, Polarity, col), directed = T, ignore.eval=FALSE, matrix.type = 'edgelist')
 df_brain <- tibble(
     variable = network.vertex.names(brain),
     betweenness = betweenness(brain, cmode = "directed", rescale = TRUE),
     indeg = sna::degree(brain, cmode ="indegree"),
     outdeg = sna::degree(brain, cmode = "outdegree"),
     closeness = sna::closeness(brain, cmode = "suminvdir", rescale = TRUE))

g6 <- ggplot(data = df_brain, aes(betweenness, closeness)) +
    geom_point(aes(color = indeg, fill = outdeg),
               shape = 21, size = 1, stroke = 1, alpha = 0.9) +
    geom_text_repel(data = filter(df_brain, betweenness > 0.015 | closeness > 0.0052),
                    aes(label = variable), size = 1.5) +
    scale_color_gradient(low = "#6495ED", high = "#00008B", guide = "colorbar", name = " Indegree") +
    scale_fill_gradient(low = "#FFD700", high = "#8B0000", guide = "colorbar", name =  "Outdegree") +
    theme_minimal(base_size = 6) + ggtitle("B") +
    theme(legend.position = "right", legend.direction = "vertical",
          legend.text = element_text(size = 4), legend.title = element_text(size = 4)) #+
    # inset(
    #     grob = ggplotGrob(
    #         ggnet2(brain, size=1, arrow.size = 1.5, arrow.gap = 0.01, edge.alpha = 0.5,
    #                edge.size = 0.1)
    #     ), xmin = 0.015, xmax =0.04 , ymin = 0, ymax = 0.004
    # )


### Insert figures with models here.
## Models for sharing drivers
df1 <- tidy(fit.w1); df1$model <- 'sharing drivers'
df1$term <- c("Non-zero",'Sum', "Landuse","Ecosystem type", "Ecosystem processes", "Provisioning services","Regulating services", "Cultural services", "Impacts on human wellbeing", "Spatial scale: national", "Spatial scale: subcontinental", "Temporal scale: month - year", "Temporal scale: week - month", "Temporal scale: year - decade", "Match spatial scale", "Match temporal scale", "Reversibility", "Evidence type")
## model for domino effects
df2 <- tidy(fit.w2); df2$model <- 'domino effects'
df2$term <- c("Non-zero",'Sum', "Landuse","Ecosystem type", "Ecosystem processes", "Provisioning services","Regulating services", "Cultural services", "Impacts on human wellbeing",
               #"Indegree - Spatial scale: national", "Indegree - Spatial scale: subcontinental", "Indegree - Temporal scale: month - year", "Indegree - Temporal scale: week - month", "Indegree - Temporal scale: year - decade",
               #"Outdegree - Spatial scale: national", "Outdegree - Spatial scale: subcontinental", "Outdegree - Temporal scale: month - year", "Outdegree - Temporal scale: week - month", "Outdegree - Temporal scale: year - decade",
              #"Match spatial scale: local","Match spatial scale: national","Match spatial scale: sub-continental", "Match temporal scale",
              "Spatial scale", "Temporal scale",
              "Reversibility", "Evidence type")
## model for hidden feedbacks
df3 <- tidy(fit.w3a); df3$model <- 'hidden feedbacks'
df3$term <- c("Non-zero",'Sum', "Landuse","Ecosystem type", "Ecosystem processes", "Provisioning services","Regulating services", "Cultural services", "Impacts on human wellbeing",
              "Spatial scale: national", "Spatial scale: subcontinental", "Temporal scale: month - year", "Temporal scale: week - month", "Temporal scale: year - decade", "Match spatial scale", "Match temporal scale",
              "Reversibility", "Evidence type")

df <- full_join(df1, df2) %>% full_join(df3) %>% as_tibble()
# df <-df %>% mutate(estimate = exp(estimate), std.error = exp(std.error)) ## In case you want to read probabilities directly instead of log odds
df <- mutate(df, conf.hi = estimate + std.error, conf.low = estimate - std.error)
df$P <- ifelse(df$p.value <= 0.05, "< 0.05", "> 0.05")
df$term <- as.factor(df$term)

# ## change names of places and reorder levels
df$term <- factor(df$term, levels(df$term)[c(9,16,6,3,2,10,11,1,5, 13,17,14,15,19,18,20,7,8, 12,4)] )

### include another category to explain the type of terms (Garry suggestion):
df_term_type <- data_frame(
    term = as_factor(levels(df$term)),
    type = fct_rev(as_factor(c(rep("context",4), rep("impacts", 5), rep("cross-scale interactions", 9), rep("context",2))) )
)

df <- df %>% left_join(df_term_type)

# df$term <- factor(df$term, levels(df$term)[c(17, 28, 11,3,2,23,24,1,5, 26,27, 30,29,31, 6:10,18:22,  12:16, 25,4)] )
# df$term <- factor(df$term, rev(levels(df$term)))

df$model <- as.factor(df$model)
df$model <- factor(df$model, levels(df$model)[c(3,1,2)])
# df$type <- factor(df$type, levels(df$type)[3:1])

## plot results
p <- ggplot(df, aes(estimate, term))+
    geom_point(aes(shape = factor(P)), size = 2, show.legend = T) +
    scale_shape_manual(name = "p value", values = c(19,1)) +
    geom_errorbarh(aes(xmax = conf.hi, xmin = conf.low, height = .15),
                   show.legend = T, size = 0.5) + #ggtitle("g)") +
    geom_vline(xintercept = 0, color = 'grey', show.legend = F, linetype = 2, size = 0.5)  +
    facet_grid(type ~ model, scales = "free", drop = TRUE, switch = "y") + theme_light(base_size = 6) +
    theme(legend.position = "right", plot.margin = margin(t=2,r=5,b=2,l=5,"pt"))


## Combine the figure old way
# gg <- list (g1,g2,g3,g4,g5,g6, p)
# source('~/Dropbox/Code/multiplot.R')
# layout <- matrix(c(1:6,7,7,7), ncol = 3, nrow = 3, byrow = T)
# multiplot(plotlist = gg, layout = layout)


## New way:
gg <- list (g1,g2)
source('~/Dropbox/Code/multiplot.R')
layout <- matrix(c(1,2), ncol = 2, nrow = 1, byrow = T)
# quartz(width = 5, height = 2.5, pointsize = 6)
multiplot(plotlist = gg, layout = layout)
# ggsave("Cascading_Fig2.png", plot = multiplot(plotlist = gg, layout = layout))
# quartz.save("Cascading_Fig2.png", type = "png", dpi = 600, bg = "white")
```

Aquatic regime shifts tend to have and share more drivers, although the driver sharing is not exclusively with other aquatic regime shifts (Fig. \ref{fig:Fig2}a, Fig S3). The resulting matrix for _driver sharing_ is a one-mode projection of the 2-mode network composed by `r dim(bipmat)[1]` drivers and `r dim(bipmat)[2]` regime shifts (Fig \ref{fig:Fig1}). The highest concentration of driver sharing is found between regime shifts in kelps, marine euthrophication, the collapse of fisheries and hypoxia. Terrestrial and polar regime shifts tend to have fewer and more idiosyncratic sets of drivers. Large-scale regime shifts in polar and sub-continental areas (e.g. Monsoon weakening) have fewer drivers but are hotspots of sharing, typically including climate-related drivers. In support of previous results [@Rocha:2015du], we find that the most co-occurring drivers are related to food production, climate change and urbanization (Fig. \ref{fig:Fig2}b). Regime shifts are more likely to share drivers when they occur in similar ecosystem types and impact similar regulating services (p << 0.001, Fig \ref{fig:Fig3}, Table S1). The likelihood of sharing drivers is also affected by occurring on similar land use, impacting similar cultural services and aspects of human wellbeing, matching spatial scales (but not temporal ones), as well as having similar types of evidence and reversibility (p < 0.05, Fig \ref{fig:Fig3}, see Table S3 for comparison with null and alternative models fitted).


```{r Fig3, cache = TRUE, echo = FALSE, error=FALSE, results = 'hide', warning=FALSE, message=FALSE, fig.height = 3, fig.width = 4, dev.args = list(pointsize= 6), fig.align='center', fig.cap = 'Statistical models summary. The response variables are the matrices of regime shifts interconnections for each cascading effect type (Fig 1). The terms fitted correspond to the categorical variables from the regime-shifts database (Table S2) that capture the similarity of regime shifts regarding their impacts on ecosystem services and human well being, the scales at which they occur, reversibility and evidence type (See SM Methods). Results from exponential random graph models are interpreted similarly to those of logistic regression where the non-zero and sum terms are the equivalent of an intercept. The non-zero term is the likelihood of the existence of a link in the response variable network, while the sum corresponds to its weight. Only best models are shown (lowest AIC or BIC), for complete results of null and alternative models fitted see Tables S3, S4 and S5.', dev = "pdf", dpi = 300}

# quartz(width=4,height=3)
p
# ggsave("Cascading_Fig3.png")
```

Intuitively, the sharing of drivers is proposed as a potential mechanism that can correlate regime shifts in space and time, but not necessarily make them interdependent [@Hughes:2013cv; @Rocha:2015du] unless they also share feedback mechanisms. Only 35% of all pair-wise combinations of regime shifts are coupled solely by driver sharing. Time correlation is debated given that spatial heterogeneity can break the synchrony induced by the sharing of drivers [@Hughes:2013cv], meaning that contextual settings matter for such correlations to emerge. Spatial heterogeneity is also attributed as a mechanism that can smooth out critical transitions and soften their abruptness [@Martin:2015kl; @Medeiros:2016vf]. Yet, with or without masking mechanisms, identifying common drivers is useful for designing management strategies that target bundles of drivers instead of well-studied variables independently, increasing the chances that managers will avoid several regime shifts under the influence of the same sets of drivers [@Rocha:2015eea; @Rocha:2015du]. For example, management options for drivers such as sedimentation, nutrient leakage, and fishing can reduce the likelihood of regime shifts such as eutrophication and hypoxia in coastal brackish lagoons, as well as coral transitions in adjacent coral reefs.

## Domino effects

```{r Fig4, cache = TRUE, echo = FALSE, error=FALSE, results = 'hide', warning=FALSE, message=FALSE, fig.height = 2, fig.width = 5, dev.args = list(pointsize= 6), fig.align='center', fig.cap = 'Domino effects. Regime shifts that produce most domino effects (high outdegree, shaded green area) are Earth system tipping points, while the regime shifts that receive the most (high indegree, orange shaded area) occur in aquatic and land-water interface (a); labels are plotted only for regime shifts where the maximum number of domino effects is found (4). Most variables associated with domino effects are related to climate and transport mechanisms (b). These variables are part of a feedback mechanism in one regime shift that are in turn drivers in another regime shift.', dev = "pdf", dpi = 300}

## New way:
gg <- list (g3,g4)
source('~/Dropbox/Code/multiplot.R')
layout <- matrix(c(1,2), ncol = 2, nrow = 1, byrow = T)
multiplot(plotlist = gg, layout = layout)
# ggsave("Cascading_Fig4.png", plot = multiplot(plotlist = gg, layout = layout))
# quartz.save("Cascading_Fig4.png", type = "png", dpi = 600, bg = "white")
```

Domino effects were investigated by searching variables that belong to feedback mechanisms in one regime shift and at the same time are drivers of another (Fig \ref{fig:Fig1}, see SM Methods). Despite having relatively fewer drivers, regime shifts that account for most domino effects include the Greenland ice sheet collapse, the Monsoon weakening, primary production in the Arctic Ocean, river-channel changes, soil salinization, weakening of the thermohaline circulation and the shift from tundra to forests (Fig \ref{fig:Fig4}). Conversely, the regime shifts that receive most influence through domino effects are mangrove transitions, kelp transitions and transitions from salt marshes to tidal flats. The maximum number of pathways found was $4$, and the variables that produce most domino effects relate to climate, nutrients and water transport (Fig \ref{fig:Fig4}). In line with our expectations, regime shifts that contain variables that will in turn be drivers of other regime shifts typically have large spatial scales and slow temporal scales: thermohaline circulation collapse, river channel change, monsoon weakening, and Greenland ice sheet collapse. On the other hand, regime shifts that receive the influence are often marine and their time and space dynamics contained more locally. The statistical models support this observation (Fig \ref{fig:Fig3}): regime shifts whose time scales are on the range of weeks to months are more likely to receive influence from regime shifts whose dynamics occur on the scale of years to decades (p < 0.1), but we did not find evidence for spatial scales (Table S4). Both, having a link and having a high number of pathways are significant (p < 0.01). The odds of having higher numbers of domino effects are increased when regime shifts impact similar regulating services and similar aspects of human well-being (p < 0.001).

## Hidden feedbacks

```{r Fig5, cache = TRUE, echo = FALSE, error=FALSE, results = 'hide', warning=FALSE, message=FALSE, fig.height = 2.5, fig.width = 6, dev.args = list(pointsize= 6), fig.align='center', fig.cap = 'Hidden feedbacks. Hidden feedbacks occur typically in terrestrial and Earth system regime shifts, (a) shows the distributions of hidden feedbacks and has been organised by higher to lower mean in the number of feedbacks. Boxplots are shown in log-scale after zero values have been removed. The variables most often involved in hidden feedbacks have high betweenness and closeness centralities (b) calculated on the network of all regime shifts in our sample (N = 30). These measures reveal the variables (labelled) that lie on most shorter pathways from all other variables in the network', dev = "pdf", dpi = 300}

## New way:
# quartz(height = 2.5, width = 7, pointsize = 6)
gg <- list (g5,g6)
source('~/Dropbox/Code/multiplot.R')
layout <- matrix(c(1,2), ncol = 2, nrow = 1, byrow = T)
multiplot(plotlist = gg, layout = layout)
# ggsave("Cascading_Fig5.png", plot = multiplot(plotlist = gg, layout = layout))
# quartz.save("Cascading_Fig5.png", type = "png", dpi = 600, bg = "white")
```

Contrary to the results found for driver sharing, most hidden feedbacks occur in terrestrial and earth systems (Fig \ref{fig:Fig5}) and typically have higher feedback length. The regime shifts with higher numbers of connections (16 to 18 out of 30 possible) are forest to savanna, monsoon weakening, thermohaline circulation, desertification, primary productivity of the Arctic Ocean and the Greenland ice sheet collapse. Key variables that belong to many of these hidden feedbacks are related to climate, fires, erosion, the functional role of herbivores, agriculture and urbanisation (Fig \ref{fig:Fig5}). The statistical analysis (Fig \ref{fig:Fig3}) shows that there is fewer hidden feedbacks that one would expect by random, but when they do occur, the odds of having multiple feedbacks coupling two regime shifts is `r round(exp(1.99143),2)` times higher. The odds of two regime shifts been connected through hidden feedbacks is not affected by occurring on similar land uses or ecosystem types. Yet, the likelihood of hidden feedbacks increases if the pair of regime shifts impact similar ecosystem processes, impact similar regulating and cultural services, and especially if they match spatial scales but not necessarily temporal ones (Fig \ref{fig:Fig3}, p < 0.001, see table S5 for null and alternative models fitted), suggesting cross-scale interactions in time.

Out of the 870 pair-wise combinations of regime shifts analysed (when taking into account directionality), ~35% are solely coupled through sharing drivers, ~4% through domino effects, and ~2% through hidden feedbacks (Fig \ref{fig:Fig6}). Furthermore, 28% of these pair-wise combinations are coupled through two different types of connections, and 10% by all three of them. Only for 167 (19%) pair-wise combinations we can be certain with the current dataset that there is no cascading effects. However, the discovery of new drivers or feedback mechanisms underlying these dynamics can reduce this estimate.

```{r Fig6, cache = TRUE, echo = FALSE, error=FALSE, warning=FALSE, message=FALSE, fig.height = 6, fig.width = 6, dev.args = list(pointsize= 8), fig.align='center', fig.cap = 'Summary of cascading effects and cross-scale interactions. Networks of regime shifts interactions are shown by cascading effect type: sharing drivers (a,d,g), domino effects (b,e,h), and hidden feedbacks (c,f,i). These circular maps show the links between regime shifts found classified by regime shift type (a,b,c), spatial scales (d,e,f), and temporal scales (g,h,i). Link width is scaled according to the number of shared drivers, domino effects or hidden feedbacks found. Figure S3 complements this figure by showing the matrix where multiple connections are expected as well as the pair-wise combinations where no connections were found.', dev = "pdf", dpi = 300}

library(circlize)
library(shape)

# quartz(width=6, height =6, family = 'Helvetica', pointsize = 8)
layout(matrix(1:9, nrow = 3, ncol = 3, byrow = TRUE))
### Figure with the balls.
### Here you need again the raw data and calculate connections between the broader categories.
df_drivers <- x %>%  # x is the netowrk of shared drivers.
    as.sociomatrix(., "paths") %>% as_tibble() %>%
    mutate(tail = rownames(as.sociomatrix(x))) %>%
    gather(key = head, value = paths,  1:30) %>%
    mutate(tail = as.factor(tail)) %>%
    mutate(tail = forcats::fct_reorder(
        tail, paths, fun = sum, .desc = FALSE)) %>%
    left_join(df_rs_type) %>% rename(link_from = type) %>%
    left_join(df_rs_type, by= c("head" = "tail")) %>% rename(link_to = type) %>%
    filter(paths > 0) %>%
    arrange(link_from) %>%
    select(link_from, link_to, paths, tail, head)

df_domino <- as_tibble(out) %>%
    select(Tail, Head, weight) %>%
    left_join(df_rs_type, by = c("Tail"="tail")) %>%
    rename(link_from = type) %>%
    left_join(df_rs_type, by = c("Head"="tail")) %>%
    rename(link_to = type) %>%
    arrange(link_from) %>%
    select(link_from, link_to, weight, Tail, Head)

df_hidden <- as_tibble(df_inc3) %>%
    select(Tail, Head, inc) %>%
    left_join(df_rs_type, by = c("Tail"="tail")) %>%
    rename(link_from = type) %>%
    left_join(df_rs_type, by = c("Head"="tail")) %>%
    rename(link_to = type) %>%
    arrange(link_from) %>%
    select(link_from, link_to, inc, Tail, Head)

## Figure 6a
par(mar = c(rep(1,4)))
# circos.par(cell.padding = c(rep(0,4)))
chordDiagram(
    df_drivers, annotationTrack = c("grid"),
    annotationTrackHeight = c( 0.1),
    #preAllocateTracks = list(track.height = 0.1),
    #directional = 1, direction.type = "arrows",link.arr.type = "big.arrow",
    link.arr.lwd = NA, grid.col = c("blue", "purple", "red","orange"))

## from tutorial
circos.trackPlotRegion(track.index = 1,
    panel.fun = function(x, y) {
        xlim = get.cell.meta.data("xlim")
        xplot = get.cell.meta.data("xplot")
        ylim = get.cell.meta.data("ylim")
        sector.name = get.cell.meta.data("sector.index")
    #if(abs(xplot[2] - xplot[1]) < 20) {
        circos.text(mean(xlim), mean(ylim), sector.name, facing = "bending.outside", niceFacing = TRUE, #adj = c(0.5, 0),
        cex = 1, col = "white") #}
    # else {circos.text(mean(xlim), ylim[1], sector.name, facing = "inside",
    #     niceFacing = TRUE, adj = c(0.5, 0), cex = .8)
    # }
    } , bg.border = NA)
title("A", adj = 0, cex = 2)
circos.clear()


## Figure 6b
par(mar = c(rep(1,4)))
# circos.par(cell.padding = c(rep(0,4)))
chordDiagram(
    df_domino, annotationTrack = "grid",
    annotationTrackHeight = c( 0.1),
    #preAllocateTracks = list(track.height = 0.1),
    directional = 1, direction.type = "diffHeight+arrows",link.arr.type = "big.arrow",
    link.arr.lwd = NA, grid.col = c("blue", "purple", "red","orange"))

## from tutorial
circos.trackPlotRegion(track.index = 1,
    panel.fun = function(x, y) {
        xlim = get.cell.meta.data("xlim")
        xplot = get.cell.meta.data("xplot")
        ylim = get.cell.meta.data("ylim")
        sector.name = get.cell.meta.data("sector.index")
    #if(abs(xplot[2] - xplot[1]) < 20) {
        circos.text(mean(xlim), mean(ylim), sector.name, facing = "bending.outside", niceFacing = TRUE, #adj = c(0.5, 0),
        cex = 1, col = "white") #}
    # else {circos.text(mean(xlim), ylim[1], sector.name, facing = "inside",
    #     niceFacing = TRUE, adj = c(0.5, 0), cex = .8)
    # }
    } , bg.border = NA)
title("B", adj = 0, cex = 2)
circos.clear()


## Figure 6c
par(mar = c(rep(1,4)))
# circos.par(cell.padding = c(rep(0,4)))
chordDiagram(
    df_hidden, annotationTrack = "grid",
    annotationTrackHeight = c( 0.1),
    #preAllocateTracks = list(track.height = 0.1),
    #directional = 1, direction.type = "arrows",link.arr.type = "big.arrow",
    link.arr.lwd = NA, grid.col = c("blue", "purple", "red","orange"))

## from tutorial
circos.trackPlotRegion(track.index = 1,
    panel.fun = function(x, y) {
        xlim = get.cell.meta.data("xlim")
        xplot = get.cell.meta.data("xplot")
        ylim = get.cell.meta.data("ylim")
        sector.name = get.cell.meta.data("sector.index")
    #if(abs(xplot[2] - xplot[1]) < 20) {
        circos.text(mean(xlim), mean(ylim), sector.name, facing = "bending.outside", niceFacing = TRUE, #adj = c(0.5, 0),
        cex = 1, col = "white") #}
    # else {circos.text(mean(xlim), ylim[1], sector.name, facing = "inside",
    #     niceFacing = TRUE, adj = c(0.5, 0), cex = .8)
    # }
    } , bg.border = NA)
title("C", adj = 0, cex = 2)
circos.clear()

#################
# Figure with scales
#################

df_scales <- data_frame(
    rs = x %v% "vertex.names",
    space = x %v% "space_range",
    time = x %v% "time_range"
)


### Space
## make a drivers df again including the scales:
df_drivers <- x %>%  # x is the netowrk of shared drivers.
    as.sociomatrix(., "paths") %>% as_tibble() %>%
    mutate(tail = rownames(as.sociomatrix(x))) %>%
    gather(key = head, value = paths,  1:30) %>%
    mutate(tail = as.factor(tail)) %>%
    mutate(tail = forcats::fct_reorder(
        tail, paths, fun = sum, .desc = FALSE)) %>%
    left_join(df_scales, by = c("tail" = "rs"))%>% rename(link_from = space) %>%
    left_join(df_scales, by= c("head" = "rs")) %>% rename(link_to = space) %>%
    filter(paths > 0) %>%
    arrange(link_from) %>%
    select(link_from, link_to, paths, tail, head)

df_domino <- as_tibble(out) %>%
    select(Tail, Head, weight) %>%
    left_join(df_scales, by = c("Tail"="rs")) %>%
    rename(link_from = space) %>%
    left_join(df_scales, by = c("Head"="rs")) %>%
    rename(link_to = space) %>%
    arrange(link_from) %>%
    select(link_from, link_to, weight, Tail, Head)

df_hidden <- as_tibble(df_inc3) %>%
    select(Tail, Head, inc) %>%
    left_join(df_scales, by = c("Tail"="rs")) %>%
    rename(link_from = space) %>%
    left_join(df_scales, by = c("Head"="rs")) %>%
    rename(link_to = space) %>%
    arrange(link_from) %>%
    select(link_from, link_to, inc, Tail, Head)

## Figure 6d
par(mar = c(rep(1,4)))
# circos.par(cell.padding = c(rep(0,4)))
chordDiagram(
    df_drivers, annotationTrack = c("grid"),
    annotationTrackHeight = c( 0.1),
    #preAllocateTracks = list(track.height = 0.1),
    #directional = 1, direction.type = "arrows",link.arr.type = "big.arrow",
    link.arr.lwd = NA , grid.col = brewer.pal(3, "Dark2")
)

## from tutorial
circos.trackPlotRegion(track.index = 1,
    panel.fun = function(x, y) {
        xlim = get.cell.meta.data("xlim")
        xplot = get.cell.meta.data("xplot")
        ylim = get.cell.meta.data("ylim")
        sector.name = get.cell.meta.data("sector.index")
    #if(abs(xplot[2] - xplot[1]) < 20) {
        circos.text(mean(xlim), mean(ylim), sector.name, facing = "bending.outside", niceFacing = TRUE, #adj = c(0.5, 0),
        cex = 1, col = "white") #}
    # else {circos.text(mean(xlim), ylim[1], sector.name, facing = "inside",
    #     niceFacing = TRUE, adj = c(0.5, 0), cex = .8)
    # }
    } , bg.border = NA)
title("D", adj = 0, cex = 2)
circos.clear()


## Figure 6e
par(mar = c(rep(1,4)))
# circos.par(cell.padding = c(rep(0,4)))
chordDiagram(
    df_domino, annotationTrack = "grid",
    annotationTrackHeight = c( 0.1),
    #preAllocateTracks = list(track.height = 0.1),
    directional = 1, direction.type = "diffHeight+arrows",link.arr.type = "big.arrow",
    link.arr.lwd = NA, grid.col = brewer.pal(3, "Dark2"))

## from tutorial
circos.trackPlotRegion(track.index = 1,
    panel.fun = function(x, y) {
        xlim = get.cell.meta.data("xlim")
        xplot = get.cell.meta.data("xplot")
        ylim = get.cell.meta.data("ylim")
        sector.name = get.cell.meta.data("sector.index")
    #if(abs(xplot[2] - xplot[1]) < 20) {
        circos.text(mean(xlim), mean(ylim), sector.name, facing = "bending.outside", niceFacing = TRUE, #adj = c(0.5, 0),
        cex = 1, col = "white") #}
    # else {circos.text(mean(xlim), ylim[1], sector.name, facing = "inside",
    #     niceFacing = TRUE, adj = c(0.5, 0), cex = .8)
    # }
    } , bg.border = NA)
title("E", adj = 0, cex = 2)
circos.clear()


## Figure 6f
par(mar = c(rep(1,4)))
# circos.par(cell.padding = c(rep(0,4)))
chordDiagram(
    df_hidden, annotationTrack = "grid",
    annotationTrackHeight = c( 0.1),
    #preAllocateTracks = list(track.height = 0.1),
    #directional = 1, direction.type = "arrows",link.arr.type = "big.arrow",
    link.arr.lwd = NA, grid.col = brewer.pal(3, "Dark2"))

## from tutorial
circos.trackPlotRegion(track.index = 1,
    panel.fun = function(x, y) {
        xlim = get.cell.meta.data("xlim")
        xplot = get.cell.meta.data("xplot")
        ylim = get.cell.meta.data("ylim")
        sector.name = get.cell.meta.data("sector.index")
    #if(abs(xplot[2] - xplot[1]) < 20) {
        circos.text(mean(xlim), mean(ylim), sector.name, facing = "bending.outside", niceFacing = TRUE, #adj = c(0.5, 0),
        cex = 1, col = "white") #}
    # else {circos.text(mean(xlim), ylim[1], sector.name, facing = "inside",
    #     niceFacing = TRUE, adj = c(0.5, 0), cex = .8)
    # }
    } , bg.border = NA)
title("F", adj = 0, cex = 2)
circos.clear()
###########################
### time
###########################
## make a drivers df again including the scales:
df_drivers <- x %>%  # x is the netowrk of shared drivers.
    as.sociomatrix(., "paths") %>% as_tibble() %>%
    mutate(tail = rownames(as.sociomatrix(x))) %>%
    gather(key = head, value = paths,  1:30) %>%
    mutate(tail = as.factor(tail)) %>%
    mutate(tail = forcats::fct_reorder(
        tail, paths, fun = sum, .desc = FALSE)) %>%
    left_join(df_scales, by = c("tail" = "rs"))%>% rename(link_from = time) %>%
    left_join(df_scales, by= c("head" = "rs")) %>% rename(link_to = time) %>%
    filter(paths > 0) %>%
    arrange(link_from) %>%
    select(link_from, link_to, paths, tail, head)

df_domino <- as_tibble(out) %>%
    select(Tail, Head, weight) %>%
    left_join(df_scales, by = c("Tail"="rs")) %>%
    rename(link_from = time) %>%
    left_join(df_scales, by = c("Head"="rs")) %>%
    rename(link_to = time) %>%
    arrange(link_from) %>%
    select(link_from, link_to, weight, Tail, Head)

df_hidden <- as_tibble(df_inc3) %>%
    select(Tail, Head, inc) %>%
    left_join(df_scales, by = c("Tail"="rs")) %>%
    rename(link_from = time) %>%
    left_join(df_scales, by = c("Head"="rs")) %>%
    rename(link_to = time) %>%
    arrange(link_from) %>%
    select(link_from, link_to, inc, Tail, Head)
## Figure 6g
par(mar = c(rep(1,4)))
# circos.par(cell.padding = c(rep(0,4)))
chordDiagram(
    df_drivers, annotationTrack = c("grid"),
    annotationTrackHeight = c( 0.1),
    #preAllocateTracks = list(track.height = 0.1),
    #directional = 1, direction.type = "arrows",link.arr.type = "big.arrow",
    link.arr.lwd = NA , grid.col = brewer.pal(4, "Dark2")
)

## from tutorial
circos.trackPlotRegion(track.index = 1,
    panel.fun = function(x, y) {
        xlim = get.cell.meta.data("xlim")
        xplot = get.cell.meta.data("xplot")
        ylim = get.cell.meta.data("ylim")
        sector.name = get.cell.meta.data("sector.index")
    #if(abs(xplot[2] - xplot[1]) < 20) {
        circos.text(mean(xlim), mean(ylim), sector.name, facing = "bending.outside", niceFacing = TRUE, #adj = c(0.5, 0),
        cex = 1, col = "white") #}
    # else {circos.text(mean(xlim), ylim[1], sector.name, facing = "inside",
    #     niceFacing = TRUE, adj = c(0.5, 0), cex = .8)
    # }
    } , bg.border = NA)
title("G", adj = 0, cex = 2)
circos.clear()


## Figure 6h
par(mar = c(rep(1,4)))
# circos.par(cell.padding = c(rep(0,4)))
chordDiagram(
    df_domino, annotationTrack = "grid",
    annotationTrackHeight = c( 0.1),
    #preAllocateTracks = list(track.height = 0.1),
    directional = 1, direction.type = "diffHeight+arrows",link.arr.type = "big.arrow",
    link.arr.lwd = NA, grid.col = brewer.pal(4, "Dark2"))

## from tutorial
circos.trackPlotRegion(track.index = 1,
    panel.fun = function(x, y) {
        xlim = get.cell.meta.data("xlim")
        xplot = get.cell.meta.data("xplot")
        ylim = get.cell.meta.data("ylim")
        sector.name = get.cell.meta.data("sector.index")
    #if(abs(xplot[2] - xplot[1]) < 20) {
        circos.text(mean(xlim), mean(ylim), sector.name, facing = "bending.outside", niceFacing = TRUE, #adj = c(0.5, 0),
        cex = 1, col = "white") #}
    # else {circos.text(mean(xlim), ylim[1], sector.name, facing = "inside",
    #     niceFacing = TRUE, adj = c(0.5, 0), cex = .8)
    # }
    } , bg.border = NA)
title("H", adj = 0, cex = 2)
circos.clear()


## Figure 6i
par(mar = c(rep(1,4)))
# circos.par(cell.padding = c(rep(0,4)))
chordDiagram(
    df_hidden, annotationTrack = "grid",
    annotationTrackHeight = c( 0.1),
    #preAllocateTracks = list(track.height = 0.1),
    #directional = 1, direction.type = "arrows",link.arr.type = "big.arrow",
    link.arr.lwd = NA, grid.col = brewer.pal(4, "Dark2"))

## from tutorial
circos.trackPlotRegion(track.index = 1,
    panel.fun = function(x, y) {
        xlim = get.cell.meta.data("xlim")
        xplot = get.cell.meta.data("xplot")
        ylim = get.cell.meta.data("ylim")
        sector.name = get.cell.meta.data("sector.index")
    #if(abs(xplot[2] - xplot[1]) < 20) {
        circos.text(mean(xlim), mean(ylim), sector.name, facing = "bending.outside", niceFacing = TRUE, #adj = c(0.5, 0),
        cex = 1, col = "white") #}
    # else {circos.text(mean(xlim), ylim[1], sector.name, facing = "inside",
    #     niceFacing = TRUE, adj = c(0.5, 0), cex = .8)
    # }
    } , bg.border = NA)
title("I", adj = 0, cex = 2)
circos.clear()
# ggsave("Cascading_Fig6.png")
# quartz.save("Cascading_Fig6.png", type = "png")
```

## Discussion

Our results show we can expect ecosystems to experience cascading regime shifts. Regime shifts that occur in similar ecosystem types and land uses are more likely to share drivers, confirming our expectation. Our analysis also suggests that sharing drivers increase when regime shifts operate at similar spatial scales, or when they impact similar provisioning or regulating services. We expected that domino effects will be more common between regime shifts whose dynamics occur at larger spatial scales and slower dynamics in time towards regime shifts more localised in space and faster in time. However, we only found support for the cross-scale dynamic in time but not in space. Additionally, aquatic regime shifts often received the domino effect supporting the idea that water acts as a potential transport mechanism linking regime shifts in one-way interactions [@Anonymous:2008gp]. Last, we expected that hidden feedbacks would emerge when scales match both in space and time, as well as under similar ecosystem types. Our results only confirm matching in spatial scales and also suggest that hidden feedbacks are common when regime shifts impact similar ecosystem processes, regulating and cultural ecosystem services.

We found $~45$% of all pair-wise combinations of regime shifts are connected by a plausible domino effect or hidden feedbacks (Fig \ref{fig:Fig6}, Fig S3). Domino effects and hidden feedbacks are often disregarded because research on regime shifts is divided by disciplines and tipycally focus on one system at the time. Consequently, data collection and hypothesis testing for coupled systems has largely remained unexplored [@Liu:2015go; @Hughes:2013cv]. Our findings align with previous results on the type of variables and processes that might couple distant regime shifts (See Table S1), highlighting the role of climate and transport mechanisms for nutrients and water (Figs \ref{fig:Fig2}, \ref{fig:Fig4}, \ref{fig:Fig5}). Recent literature (refs. in Table S1) reports potential linkages between euthrophication and hypoxia, hypoxia and coral transitions, shifts in coral reefs and mangroves transitions, or climate interactions. Other examples in the terrestrial realm report potential increase in Arctic warming from higher fire frequency in boreal forest or permafrost thawing. Regime shifts in the Arctic can impact any temperature driven regime shift in and outside the Arctic [@Peterson:2016ul], including the weakening of the thermohaline circulation. Moisture recycling is a key underlying feedback on the shift from forest to savanna or the Indian monsoon; but also has the potential to couple ecosystems beyond the forest that depend on moisture recycling as an important water source. Changes in moisture recycling can affect mountain forest in the Andes, nutrient cycling in the ocean by affecting sea surface temperature and therefore regime shifts in marine food webs, or exacerbation of dry land related regime shifts. These connections between regime shifts represent an emergent literature on regime shifts interactions (Table S1 and references therein). We contribute to this endeavour with a network-based method that allow us to explore plausible cascading effects and distinguish potential correlations from true interdependencies. Distinguishing whether the coupling is expected to be correlational because of driver sharing, a one-way causation (the _domino effect_), or a two-way interaction (the _hidden feedbacks_), provides a useful set of hypotheses for future research.

While our method identifies plausible connections between regime shifts, identifying under what conditions plausible becomes probable requires more detailed understanding on regime shifts mechanisms. Empirical studies and modelling syntheses are required to translate our identification of possible mechanisms into context sensitive forecasts. Dynamic models of this type of dynamics require careful assumptions about parameter values as well as functional form of the system's equations. Generalised modelling is a promising technique that does not require particular assumptions allowing the researcher to reach more general conclusions based on stability properties of the system [@Gross:2009jr; @Lade:2013iwa]. Another potential avenue for future research is looking at how transport mechanisms couple far-apart ecosystems. One example already mentioned is the moisture recycling feedback [@Keys:2012bo]. Another important social teleconnection (sensu [@Liu:2015go]) could be with allocation of resources through international trade, investigating how demand of resources in certain countries can shape the state space of ecosystems from the providing countries. An important lesson from our study is that regime shifts can be interconnected, they should not be study in isolation assuming they are independent systems. On the contrary, methods and data collection that takes into account the possibility of cascading effects needs to be further developed.

The frequency and diversity of regime shifts interconnections suggests that current approaches to environmental management and governance are substantially underestimating the likelihood of cascading effects. More attention should be paid to how the Earth is social-ecologically connected [@Liu:2015go], how those connections should be managed, and how to best prepare for regime shifts. Our research suggests that regional ecosystems can be transformed by ecosystem management far away, and conversely, can themselves drive the transformations of other distant ecosystems. Decisions made in one place can undermine the achievement of sustainable development goals in other places. For example, it has been shown that what happens in the Arctic does not stay in the Arctic [@Cvijanovic:2017hn; @Peterson:2016ul], many Arctic regime shifts have the potential to impact non-Arctic ecosystems far away and the provision of their ecosystem services. It implies that whoever does make decisions on management is not necessarily the one that has to deal with the impacts. This issue is evident in governance of water transport systems, whether run-off or atmospheric transport, but it is applicable to other dynamics connecting far-away ecosystems through other mechanisms such as climate change, fire, nutrient inputs or trade. Our results highlight variables that are key for domino effects and hidden feedbacks. They are also good observables for monitoring early warning indicators of the strengthening of regime-shifts coupling.

## Conclusions

Regime shifts occur across a wide range of ecosystems. However, how a regime shift somewhere in the world could affect the occurrence of another regime shift remains an open question and a key frontier of research. We propose two types of cascading effects that can connect different regime shifts: domino effects, and hidden feedbacks; and compare them with the case of driver sharing. To assess these cascading effects among regime shifts we developed a network-based method that identified plausible cascading effects. Regime shifts that occur in similar ecosystems and land uses are more likely to share drivers, and consequently respond similarly to environmental change. One-way directional interactions or _domino effects_ are common but not exclusive to aquatic regime shifts, it highlights the role of water transport and tend to emerge between regime shifts whose dynamics occur at similar temporal scales. Two-way interconnections or _hidden feedbacks_ are more common in terrestrial systems, they occur often between regime shifts that match spatial scales and impact similar ecosystem processes. These results suggest that the Anthropocene can be expected to increase ecological surprise. How and when nonlinear change can be transmitted across space and time in the earth system should be considered in assessments of future environmental change and planning.


### Acknowledgements
We are grateful to the contributors, reviewers and developers of the regime shifts database. This work was supported by FORMAS grant 942-2015-731 to JR, and National Science Foundation grant OCE-1426746 to SL. JR designed the research, JR and GP curated the data, JR wrote the code and run the analysis with guidance from GP, ÖB and SL; JR, GP, ÖB and SL wrote the paper. Authors declare no competing interests. Data from the regime shifts database is publicly available at [www.regimeshifts.org](www.regimeshifts.org). Upon publication, the version of the database used, curated causal networks, and code will be made available in both the regime shifts database and an online repository (e.g. figshare or dryad). The development version of the code is available at: https://github.com/juanrocha/Domino


\pagebreak


## Supplementary material

: Summary of examples from the literature

| Regime shift 1 | Regime Shift 2 | Type | Reference |
|:--------------:|:--------------:|:--------------:|:--------------:|
| Marine eutrophication | Hypoxia | Sharing drivers, domino effect | [@Diaz:2008p199] |
| Hypoxia | Coral transitions | Domino effect | [@Altieri:2017bl] |
| Forest to savanna | Mountain forest transitions | Domino effect | [@Clark:2015bj; @MoruetaHolme:2015fy] |
| Forest to savanna | Marine food webs | Domino effect | [@Bakun:2010p5340] |
| Forest to savanna | Dryland degradation | Domino effect | [@DebraPCPeters:2004ex] |
| Coniferous to deciduous boreal forest | Arctic sea ice loss | Hidden feedback | [@Young:2016kj; @Kelly:2015iq] |
| Peatland transitions | Arctic sea ice loss | Hidden feedback | [@Zona:2016hq] |
| Arctic sea ice loss | Thermohaline circulation weakening | Hidden feedback | [@Sevellec:2017fk] |
| Antarctic sea ice loss | Marine food webs | Hidden feedback | [@Moore:2018ci] |
| Thermohaline circulation weakening | ENSO | Domino effect | [@Dekker:2018jk] |

### Supplementary methods:

This section complements the methods and results from the exponential random graph models. The modeling technique used the number of drivers shared, the number of domino effects and the number of hidden feedback as the three key response variables (Fig 1). The use of exponential random graph models is motivated because it take into account network structure and allow us to control for sample bias. It investigates the odds of the existence and weight of a link and its results are interpreted similarly to a logistic regression.

_Data_: The [regime shifts database](www.regimeshifts.org) synthesizes scientific literature on our current knowledge on regime shifts. It is an open online repository of regime shift syntheses and case studies. When possible, entries to the regime shifts database have been peer-reviewed by an expert on the topic to ensure quality and accuracy of its contents [@Biggs:2015iha]. The main data used in this study are the causal loop diagrams described in the database (Fig S1), and a set of categorical variables about regime shifts attributes that were used to fit statistical models to explore the role of cross scale interactions (described below). Out of the 35 regime shifts documented in the database, here we use 30 where complete synthesis exist and causal loop diagrams have been curated.

_Causal loop diagrams_ (CLDs) represent a collection of causal mechanisms that scientist have reported in their narratives: both empirical (what they choose to sample) or theoretical (what they choose to model). CLDs consist of variables connected by arrows denoting causal influence [@Sterman:2000we], also known as signed directed graphs. Each relationship must have a positive $(+)$ or negative $(-)$ sign that represents the effect of the dependent variable given change on the independent variable [@Lane:2008p6781; @Sterman:2000we]. Although the functional form that underlies each relationship is not necessarily known, positive relationships are proportional while negative ones are inversely proportional _ceteris paribus_. CLDs assume that the causal relationships captured by links are monotonic, while non-linearities are captured by links sets: thus they do not have self-loops. Feedback loops are the basic structural units of the diagram and emerge by connecting variables in closed directed paths (cycles). Feedback means that once a signal enters the loop, some part of the output is fed back to the input, resulting in amplification or dampening of its own signal. Feedbacks can be reinforcing if the overall polarity of its links is positive, or balancing if negative. Reinforcing feedbacks are usually responsible for behaviors that drive the system out of equilibrium, while balancing feedbacks are responsible for near equilibrium dynamics such as oscillations and delays [@Sterman:2000we]. Note that causal links do not describe the behavior of variables, only the structure of the system: they describe what would happen if there were changes [@Sterman:2000we]. CLDs were curated in the regime shifts database in a way that variables names are consistent (e.g. agriculture and cropping is kept as 'agriculture'), and feedback loops comparable (e.g. albedo in the rainforest, Arctic or Antarctic regime shifts is the same feedback). Fig S1 shows all CLD's used in the analysis.


```{r FigS1, cache = TRUE, echo = FALSE, error=FALSE, warning=FALSE, message=FALSE, fig.height = 10, fig.width = 10, dev.args = list(pointsize= 7), fig.align='center', fig.cap = 'Fig S1. Causal networks for all regime shifts analysed', fig.lp = ""}

## Updated ploting function
quartz(width = 8, height=6, pointsize= 9)
# detach(package:igraph)
library(network); library(sna)
# quartz(pointsize = 7)
par(mfrow = c(6,5), mar = c(0.25,0.25,1.25,0.25))

for (i in 1:length(levels(dat$Regime.Shift)) ){
	net <- rs.net(dat = dat,  i = i)
	plotnet(net)

}

# quartz.save("Cascading_FigS1_CLDs.png", type = "png", dpi = 800)

```

_Categorical variables:_ We calculated the similarity of each pair-wise combination of regime shifts in the database regarding categorical attributes (Table S2) such as *(i)* land use under which the regime shift occur, *(ii)* ecosystem type, impacts on *(iii)* ecosystem processes, *(iv)* provisioning services, *(v)* regulating services, *(vi)* cultural services, *(vii)* and human wellbeing; as well as *(viii)* the spatial scale at which the regime shift occur, *(ix)* the temporal scales, *(x)* reversibility, and *(xi)* evidence type [@Biggs:2015iha; @Rocha:2015du]. For all $75$ categorical variables encoded, the database reports presence or absence $(0,1)$ allowing us to calculate the Jaccard index and use it as a proxy of how similar two regime shifts are. To facilitate the interpretation of statistical models, the Jaccard distance was rescaled ($x =1 - J_{d}$) so equivalent regime shifts score 1 and complete dissimilar zero. Given that most of our hypotheses relate to the scale at which regime shifts occur, we also modelled scale as a categorical variable to account for matches in the network, not only similarity. Figure S2 shows a map with all generic types of regime shifts and case studies reported in the regime shifts database.



```{r table_2, cache = TRUE, echo = FALSE, error=FALSE, warning=FALSE, message=FALSE}
text_tbl <- data_frame(
    Terms = c("Land use", "Ecosystem type", "Ecosystem processes", "Provisioning services", "Regulating services", "Cultural services", "Impacts on human well being", "Spatial scale", "Temporal scale", "Reversibility", "Evidence type"),
    Explanation = c("Land use under which the regime shift occurs", "Ecosystem type in which the regime shift occurs", "Impacts on key ecosystem processes",
                    "Impacts on provisioning ecosystem services", "Impacts on regulating ecosystem services", "Impacts on cultural ecosystem services",
                    "Impacts on aspects of human well being", "Typical spatial scale at which the regime shift occurs",
                    "Typical time scale at which the regime shifts occurs", "Reversibility of the regime shift", "Evidence type in the literature"),
    Variables = c("Urban, small-scale subsistence crop cultivation, large-scale commercial crop cultivation,
                  intensive livestock production (eg feedlots, dairies), extensive livestock production (natural rangelands),
                  timber production, fisheries, mining, conservation,
                  tourism, land use impacts are primarily off-site)",
                  "Marine and coastal, freshwater lakes and rivers, temperate and boreal forests, tropical forests, moist savannas and woodlands, drylands and deserts (below ~500mm rainfall/year), mediterranean shrub (e.g. fynbos), grasslands, tundra, rock and ice, agro-ecosystems, planetary",
                  "Soil formation, primary production, nutrient cycling, water cycling, impacts on biodiversity",
                  "Freshwater, food crops, livestock, fisheries, wild animal and plant products, timber, woodfuel, feed fuel and fiber crops, hydropower",
                  "Air quality regulation, climate regulation, water purification, water regulation, regulation of soil erosion, pest and disease regulation, pollination, natural hazard regulation",
                  "Recreation, aesthetic values, knowledge and educational values, spiritual and religious",
                  "Food and nutrition, health (eg toxins, disease), livelihoods and economic activity, security of housing and infrastructure, aesthetic and recreational values, cultural identity, social conflict, no direct impact",
                  "Local/landscape (e.g. lake, catchment, community), national (country), sub-continental (e.g. southern Africa, Amazon basin), global",
                  "Weeks, months, years, decades, centuries, unknown",
                  "Irreversible (on 100 year time scale), hysteretic (difficult to reverse), readily reversible, unknown",
                  "Models, paleo-observation, contemporary observations, experiments, other")
)

kable(text_tbl, format = "latex", booktabs = TRUE,
      caption = "Summary of categorical variables") %>%
    kable_styling(full_width = TRUE, latex_options = c("scale_down", "HOLD_position"),
                  font_size = 8) %>%
    column_spec(3, width = "4in") #%>%
    # add_footnote(c("Source: the regime shifts database [www.regimeshifts.org]"), notation = "symbol")
```

```{r FigS2, cache = TRUE, echo = FALSE, error=FALSE, warning=FALSE, message=FALSE, fig.height = 4, fig.width = 6, fig.align = 'center', fig.cap = "Fig S2. Regime shifts around the world. Large points show generic types of regime shifts (n = 35) while small points are case studies (n=324).", dev.args = list(pointsize = 5), fig.lp = ""}

coords <- read.csv2("~/Documents/Projects/Cascading Effects/Domino/case_coords.csv", dec = '.')

coord_rs <- read.csv(file = '~/Documents/Projects/Cascading Effects/Domino/rs_coords.csv', dec = '.')
cases <- cbind(cases, coords)
rs <- cbind(rs, coord_rs)
rs$rs <- as.factor(rs$rs)
cases$Type.of.regime.shift <- as.factor(cases$Type.of.regime.shift)
names(cases)[7] <- 'rs'

# correction on RS names for plotting
levels(rs$rs) [17] <- "Marine food webs"
levels(rs$rs) [28] <- "Thermokarst lakes"
levels(cases$rs)[17] <- "Fisheries collapse"
levels(cases$rs)[c(5,22)] <- "Marine food webs"
levels(cases$rs)[c(2,9,12,17,20)] <- "Other"


world <- map_data('world')
world <- fortify(world)

m <- ggplot(world, aes(long, lat)) +
    geom_polygon(fill="grey90", aes(group = group)) +
    geom_path(color="white",aes(group=group), size = 0.2) +
    coord_equal() + theme_void(base_size = 7, base_family = "Helvetica")

m + geom_point(data = cases, aes(lon, lat, color = rs), size = 0.2, show.legend = F) +
    geom_point(data = rs, aes(lon,lat, color = rs), size = 2, show.legend = T ) +
    theme(legend.position = "bottom", legend.text = element_text(size = 4)) +
    scale_color_discrete(guide = guide_legend(title = "Regime shifts documented on the regime shifts database \n Source: www.regimeshifts.org", title.position = 'top', title.hjust = 0.5))

# png(file="rsdb_map.png", width=1280, height = 768, units = "px")
# dev.off()
# quartz.save("rsdb_map.png", width= 12, height=7, pointsize = 10, dpi = 800, bg = "white")

```

_Networks:_ Causal loop diagrams were reinterpreted as networks where node attributes were coded if a node belonged to a feedback loop -a k-cycle in the network- or not. The later is then by definition a driver, an independent variable whose dynamics are not affected by the dynamics of the state variables of the system at hand. Note that networks in ecology usually describe inter-species interactions such as predation or mutualism. Our approach is different from what has been done in ecology. Here a network describes a set of processes, both biotic and abiotic, that can govern ecosystem regime-shift dynamics. Our approach is inspired by other network applications to processes such as cell metabolic networks or the network of human diseases, where a process is not captured by a link type (e.g. predation) but by a collection of link interactions (e.g. the Krebs cycle). Thus, individual species are not taken into consideration, but rather their functional roles at the aggregated ecosystem scale (e.g. herbivory).

_Shared drivers:_ To study shared drivers we created a bipartite network of drivers and regime shifts following the method outlined by Rocha et al [@Rocha:2015du]. The statistical models were performed for the case of driver sharing on the one-mode network projection of regime shifts sharing drivers (this is the matrix $A^TA$), and categorical variables from the regime-shifts database were used as node attributes or node covariates to test our hypothesis.

_Domino effects:_ occur when the occurrence of a regime shift can increase or decrease the likelihood of other regime shifts occurring, creating a one-way dependence. Different from the driver-sharing network, here we explore potential domino effects by using the full causal loop diagrams as networks. The algorithm for identifying domino effects takes the adjacency matrix of two given regime shifts $A_1$ and $A_2$ and identifies all nodes $n \in A_1 \cap A_2$ such that $n$ belong to a feedback in $A_1$ but is a driver in $A_2$. Thus, set differences between causal pathways suggest missing drivers, and set intersection between causal pathways and feedback loop nodes indicate potential domino effects (Fig. 2b). By iterating this simple algorithm we derived how many different pathways exist between every pair-wise combination of regime shifts $(N=870)$. The resulting non-symmetrical matrix represents a directed network with regime shifts as nodes and link weights as the number of pathways used for statistical analysis.

_Hidden feedbacks:_ We explore hidden feedbacks by pair-wise comparison of causal networks. First, the feedback loops (or k-cycles) are counted by feedback length $k$ for each regime shift matrix  $A_1$ and $A_2$ separately. Then the cycle count is applied to the composite network $A_{1,2}$ of the two regime shifts. The difference between the k-cycles in the composite network $A_{1,2}$ and the k-cycles in the individual networks $A_1$ and $A_2$ are the hidden feedbacks that emerge when the two causal networks are joined. By iterating the same procedure to all pair-wise combinations of regime shifts $(N=435)$ we obtain a symmetric directed matrix that is then used for the statistical analysis. Although computationally intensive, the search for cycles is feasible in our networks given the small size and relative sparse structures. In fact, the maximum cycle length $k$ is bounded by the size of the network. Out of the `r length(out_inc)` coupled networks analysed, the maximum feedback length was `r unlist(lapply(out_inc, network.size) ) %>% max`.

```{r matrixes_fig, cache = TRUE, echo = FALSE, error=FALSE, warning=FALSE, message=FALSE, fig.height = 7, fig.width = 7, dev.args = list(pointsize= 6), fig.align='left', fig.cap = 'Fig S3. Response variable matrices and summary of all cascading effects in matrix form.', dev = "pdf", dpi = 300, fig.lp = ""}


df_fork <- as.sociomatrix(x, "paths") %>% as_tibble() %>% mutate(tail = rownames(as.sociomatrix(x))) %>%
        gather(key = head, value = drivers,  1:30) %>% mutate(tail = as.factor(tail) %>% forcats::fct_rev()) %>%
    mutate(drivers = ifelse(drivers > 0, 1, 0))
# domino <- as.sociomatrix(dom_net)
# inconvenient <- as.sociomatrix(inc_net)

# inconvenient <- cbind(inconvenient, rep(0,29))
# inconvenient <- rbind(inconvenient, rep(0,30))
#
# colnames(inconvenient)[30] <- "Sprawling vs compact city"
# rownames(inconvenient)[30] <- "Sprawling vs compact city"
#
# inconvenient <- clean.and.order(inconvenient)

# all <- as.data.frame(fork + domino + inconvenient)
# all$from <- rownames(all)
# df_all <- gather(all,  1:30, key = to, value = count)


df_domino <- as_tibble(out) %>% rename(tail = Tail, head = Head) %>%
    mutate(domino = ifelse(weight > 0, 1, 0)) %>% select(-driv2feed, -weight)
df_hidden <- as_tibble(df_inc3) %>% rename(tail = Tail, head = Head) %>%
    mutate(hidden = ifelse(inc > 0, 1, 0)) %>% select(-inc)


df_all <- left_join(df_fork, df_domino) %>% left_join(df_hidden) %>%
    group_by(tail,head) %>%
    mutate(all = sum(drivers, domino, hidden),
           type = ifelse(is.na(all), NA,
                         ifelse(all == 3, "all",
                                ifelse(all == 2, "multiple",
                                       ifelse(all == 1 && drivers == 1, "drivers sharing",
                                              ifelse(all == 1 && domino == 1, "domino effect",
                                                     ifelse(all == 1 && hidden == 1, "hidden feedback", NA)
                                                     )
                                              )
                                       )
                                )
           )
    )

df_all$type <- as.factor(df_all$type) %>% forcats::fct_relevel(
    "drivers sharing", "domino effect", "hidden feedback", "multiple", "all") %>%
    forcats::fct_rev() # %>%
    #fct_collapse(multiple = c('all', 'multiple')) #%>%
    # fct_explicit_na(na_level = "other") %>%
    # fct_collapse(other = c("drivers sharing", "other"))

m4 <- df_all %>% ungroup() %>% # filter(fork == 1, domino ==0, inc ==0) %>%
    mutate(tail = as.factor(tail) %>% forcats::fct_rev(),
               head = as.factor(head)) %>% #%>% forcats::fct_rev()),
    ggplot(aes(y = tail, x = head)) +
    geom_tile(aes(fill= type)) +
    scale_fill_brewer(type = "seq", palette = "YlOrBr", direction = -1, na.value = "gray57",
                      guide = guide_legend(title = "Cascading effects", barwidth = 0.5)) +
    theme_light(base_size = 6) + xlab('') + ylab('') + ggtitle("Summary matrix") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5 ),
          legend.position = "bottom")


lay <- rbind(c(1,1,2,2),
             c(NA,3,3,NA))
grid.arrange(m1,m2,m3,m4, layout_matrix = matrix(1:4,2,2, byrow = T))

```


### Exponential random graph models
The coefficients in exponential random graph models present the log-odds of the existence of a link given the similarites (Jaccard distances) or matching of node attributes (e.g. scale). Thus, their results are read similarly to those of a logistic regression. Instead of the intercept here we have the `nonzero` term which indicates what the odds are of the existence of a link. Since the networks are weighted by the number of shared drivers, domino effects or hidden feedbacks, the term `sum` accounts for the weight of the link when it exists. We used Jaccard similarity on the attributes coded in the regime shifts database to quantify how similar two regime shifts are and how the similarity affects the odds of a link. Since our hypotheses were related to the temporal and spatial scales at which the regime shifts occurred, we also modeled such terms not only as similarity (a score between 0 and 1), but also as categorical mutually exclusive variables. The original data from the regime shifts database coded for categorical non-exclusive variables. For spatial scale, when two different categories where present (e.g. local, national), we choose the larger category as the unique factor. For temporal scales, regime shifts were often coded as belonging to two categories (e.g. decades and centuries), thus we create a variable `time-range` that bundles both minimum and maximum reported. Spatial and temporal scales are then also modelled as factors too, the term `nodefactor` in each model accounts for how more likely is to have a link when the factor is present, while the `nodematch` term accounts for the homogeneity effect of two nodes sharing the same node attribute (same scale). The analysis was performed in R statistical language [@RCoreTeam:2012wf] using packages for modeling networks with exponential random graph models [@Handcock:2008p5095; @Hunter:2008vh; @Morris:2008ty; @Hunter:2007bq].

\pagebreak

**Table S3.** Exponential random graph models for \textit{shared drivers}
```{r tableSM2, message = FALSE, warning = FALSE, echo = FALSE, results='asis'}

suppressMessages(stargazer::stargazer(fit.null1, fit.w1, fit.w1a,
    align = F, header = F, type = 'latex', digits = 2,
    float = F, no.space = T, single.row = T, font.size = "footnotesize",
    title = "Table S2. Exponential random graph models for shared drivers (\textit{number of drivers shared})",
    covariate.labels = c("Non-zero", "Sum", "Land use", "Ecosystem type", "Ecosystem processes",
                         "Provising services", "Regulating services", "Cultural services",
                         "Human wellbeing", "Spatial scale: National",
                         "Spatial scale: sub-continental", "Temporal scale: month-year",
                         "Temporal scale: week-month", "Temporal scale: year-decade", "Spatial scale match",
                         "Temporal scale match", "Spatial scale similarity", "Temporal scale similarity",
                         "Reversibility",
                         "Evidence type"),
    dep.var.labels = "Shared drivers",
    add.lines = list(c("Maximum likelihood estimation",
                       round(fit.null1$mle.lik,2),
                       round( fit.w1$mle.lik,2),
                       round(fit.w1a$mle.lik,2))))
    )

```

\pagebreak

**Table S4.** Exponential random graph models for \textit{domino effects}
```{r tableSM3, message = FALSE, warning = FALSE, echo = FALSE, results='asis'}
suppressMessages(stargazer::stargazer( fit.null2, fit.w2, fit.w2a, fit.w2b,
    align = F, header = F, type = 'latex', digits = 2,
    float = F, no.space = T, single.row = T, font.size = "footnotesize",
    title = "Table S3. Exponential random graph models for \textit{domino effects}",
    covariate.labels = c("Non-zero", "Sum", "Land use", "Ecosystem type", "Ecosystem processes",
                         "Provising services", "Regulating services", "Cultural services",
                         "Human wellbeing",
                         "Spatial scale similarity", "Temporal scale similarity",
                         "Spatial scale: national", "Spatial scale: sub-continental",
                         "Temporal scale: year", "Temporal scale: month", "Temporal scale: decade",
                         "Indegree when spatial scale national", "Indegree when spatial scale subcontinental",
                         "Indegree when temporal scale year", "Indegree when temporal scale month",
                         "Indegree when temporal scale decade", "Outdegree when spatial scale national",
                         "Outdegree when spatial scale subcontinental", "Outdegree when temporal scale year",
                         "Outdegree when temporal scale month", "Outdegree when temporal scale decade",
                         "Spatial scale match: local", "Spatial scale match: national",
                         "Spatial scale match: sub-continental", "Temporal scale match",
                         "Reversibility",
                         "Evidence type"),
    dep.var.labels = "Domino effects",
     add.lines = list(c("Maximum likelihood estimation",
                       round(fit.null2$mle.lik,2),
                       round( fit.w2$mle.lik,2),
                       round(fit.w2a$mle.lik,2),
                       round(fit.w2b$mle.lik,2))))
    )
```

\pagebreak

**Table S5.** Exponential random graph models for \textit{hidden feedbacks}
```{r tableSM4, message = FALSE, warning = FALSE, echo = FALSE, results='asis'}
suppressMessages(stargazer::stargazer(fit.null3, fit.w3, fit.w3a,
    align = F, header = F,  type = 'latex', digits = 2,
    float = F, no.space = T, single.row = T, font.size = "footnotesize",
    title = "Table S4. Exponential random graph models for \textit{hidden feedbacks}",
    covariate.labels = c("Non-zero", "Sum", "Land use", "Ecosystem type", "Ecosystem processes",
                         "Provising services", "Regulating services", "Cultural services",
                         "Human wellbeing", "Spatial scale", "Temporal scale",
                         "Spatial scale: national", "Spatial scale: sub-continental",
                         "Temporal scale: year", "Temporal scale: month", "Temporal scale: decade",
                         "Spatial scale match", "Temporal scale match",
                         "Reversibility",
                         "Evidence type"),
    dep.var.labels = "Hidden feedbacks",
    add.lines = list(c("Maximum likelihood estimation",
                       round(fit.null3$mle.lik,2),
                       round( fit.w3$mle.lik,2),
                       round(fit.w3a$mle.lik,2))))
    )
```


\pagebreak
